---
title: "Buffer Views"
---

# Buffer Views

Buffer views provide low-level memory access abstractions in PythonCK, supporting different address spaces and memory access patterns common in GPU computing.

```{pyodide}
#| echo: false
#| output: false
# Hidden setup - automatically install the package
import micropip
try:
    base_url = str(js.window.location.origin)
    wheel_url = f"{base_url}/pythonck-0.1.0-py3-none-any.whl"
    await micropip.install(wheel_url)
except:
    try:
        await micropip.install("./pythonck-0.1.0-py3-none-any.whl")
    except:
        pass  # Package may already be installed
```

## Setup

```{pyodide}
from pytensor.buffer_view import BufferView, AddressSpaceEnum, MemoryOperationEnum, make_buffer_view
import numpy as np
print("âœ… Buffer view modules imported successfully!")
```

## Basic Buffer Creation

Create different types of buffer views for various memory spaces:

```{pyodide}
# Create a simple global memory buffer
data = np.array([1, 2, 3, 4, 5, 6, 7, 8], dtype=np.float32)
print(f"Original data: {data}")

# Create buffer view
buffer = BufferView(
    address_space=AddressSpaceEnum.GLOBAL,
    data=data,
    buffer_size=len(data),
    invalid_element_use_numerical_zero=True
)

print(f"Buffer: {buffer}")
print(f"Buffer size: {buffer.buffer_size}")
print(f"Data type: {buffer.dtype}")
```

## Memory Access Patterns

Buffer views support various access patterns with bounds checking:

```{pyodide}
# Create a buffer for testing access patterns
data = np.arange(16, dtype=np.int32)
buffer = BufferView(
    address_space=AddressSpaceEnum.GLOBAL,
    data=data,
    buffer_size=len(data)
)

print(f"Buffer data: {data}")

# Basic element access
print(f"Element at index 5: {buffer[5]}")
print(f"Element at index 10: {buffer[10]}")

# Access with validity checking
valid_element = buffer.get(
    index=0,           # Base index
    linear_offset=7,   # Offset from base
    is_valid_element=True,
    vector_size=1
)
print(f"Valid access at offset 7: {valid_element}")

# Invalid element access
invalid_element = buffer.get(
    index=0,
    linear_offset=20,  # Out of bounds
    is_valid_element=True,
    vector_size=1
)
print(f"Out-of-bounds access: {invalid_element}")
```

## Vectorized Access

Buffer views support vectorized read and write operations:

```{pyodide}
# Create buffer for vectorized operations
data = np.arange(20, dtype=np.float32)
buffer = BufferView(
    address_space=AddressSpaceEnum.GLOBAL,
    data=data
)

print(f"Original data: {data}")

# Vectorized read (4 elements starting at index 5)
vector_data = buffer.get(
    index=0,
    linear_offset=5,
    is_valid_element=True,
    vector_size=4
)
print(f"Vector read (4 elements from index 5): {vector_data}")

# Vectorized write
new_values = np.array([100, 101, 102, 103], dtype=np.float32)
buffer.set(
    index=0,
    linear_offset=8,
    is_valid_element=True,
    value=new_values,
    vector_size=4
)

print(f"After vectorized write: {buffer.data}")
```

## Memory Operations

Different types of memory operations are supported:

```{pyodide}
# Create buffer for memory operations
data = np.array([10, 20, 30, 40, 50], dtype=np.float32)
buffer = BufferView(
    address_space=AddressSpaceEnum.GLOBAL,
    data=data
)

print(f"Initial data: {buffer.data}")

# SET operation (overwrite)
buffer.update(
    operation=MemoryOperationEnum.SET,
    index=0,
    linear_offset=2,
    is_valid_element=True,
    value=99.0
)
print(f"After SET at index 2: {buffer.data}")

# ADD operation (accumulate)
buffer.update(
    operation=MemoryOperationEnum.ADD,
    index=0,
    linear_offset=2,
    is_valid_element=True,
    value=1.0
)
print(f"After ADD at index 2: {buffer.data}")

# ATOMIC_MAX operation
buffer.update(
    operation=MemoryOperationEnum.ATOMIC_MAX,
    index=0,
    linear_offset=1,
    is_valid_element=True,
    value=25.0
)
print(f"After ATOMIC_MAX at index 1: {buffer.data}")
```

## Address Space Types

Different address spaces can be used for different memory hierarchies:

```{pyodide}
# Create buffers for different address spaces
data = np.array([1, 2, 3, 4], dtype=np.int32)

# Global memory (GPU global memory)
global_buffer = BufferView(
    address_space=AddressSpaceEnum.GLOBAL,
    data=data.copy()
)

# Local Data Share (GPU shared memory)
lds_buffer = BufferView(
    address_space=AddressSpaceEnum.LDS,
    data=data.copy()
)

# Vector registers
vgpr_buffer = BufferView(
    address_space=AddressSpaceEnum.VGPR,
    data=data.copy()
)

print(f"Global buffer: {global_buffer.get_address_space().name}")
print(f"LDS buffer: {lds_buffer.get_address_space().name}")
print(f"VGPR buffer: {vgpr_buffer.get_address_space().name}")
```

## Invalid Element Handling

Buffer views provide flexible handling of invalid or out-of-bounds accesses:

```{pyodide}
# Create buffer with custom invalid element handling
data = np.array([10, 20, 30], dtype=np.float32)

# Buffer that returns zero for invalid elements
zero_buffer = BufferView(
    address_space=AddressSpaceEnum.GLOBAL,
    data=data,
    invalid_element_use_numerical_zero=True
)

# Buffer that returns custom value for invalid elements
custom_buffer = BufferView(
    address_space=AddressSpaceEnum.GLOBAL,
    data=data,
    invalid_element_use_numerical_zero=False,
    invalid_element_value=-999.0
)

print(f"Data: {data}")

# Test out-of-bounds access
oob_zero = zero_buffer.get(0, 10, True, 1)  # Out of bounds
oob_custom = custom_buffer.get(0, 10, True, 1)  # Out of bounds

print(f"Out-of-bounds with zero handling: {oob_zero}")
print(f"Out-of-bounds with custom value: {oob_custom}")

# Test invalid element access
invalid_zero = zero_buffer.get(0, 1, False, 1)  # Element marked as invalid
invalid_custom = custom_buffer.get(0, 1, False, 1)  # Element marked as invalid

print(f"Invalid element with zero handling: {invalid_zero}")
print(f"Invalid element with custom value: {invalid_custom}")
```

## Practical Example: Matrix Tile Operations

Let's use buffer views to implement a simple matrix tile operation:

```{pyodide}
def process_matrix_tile(matrix_buffer, tile_row, tile_col, tile_size):
    """Process a tile of a matrix using buffer view operations."""
    result = []
    
    for i in range(tile_size):
        for j in range(tile_size):
            # Calculate global position
            global_row = tile_row * tile_size + i
            global_col = tile_col * tile_size + j
            linear_offset = global_row * 8 + global_col  # Assuming 8 columns total
            
            # Read element
            element = matrix_buffer.get(
                index=0,
                linear_offset=linear_offset,
                is_valid_element=True,
                vector_size=1
            )
            
            # Simple processing: square the element
            processed = element * element
            
            # Write back
            matrix_buffer.set(
                index=0,
                linear_offset=linear_offset,
                is_valid_element=True,
                value=processed
            )
            
            result.append(processed)
    
    return result

# Create a 4x8 matrix
matrix_data = np.arange(32, dtype=np.float32).reshape(4, 8)
print("Original matrix:")
print(matrix_data)

# Create buffer view
matrix_buffer = BufferView(
    address_space=AddressSpaceEnum.GLOBAL,
    data=matrix_data.flatten()
)

# Process a 2x2 tile at position (1, 2)
tile_result = process_matrix_tile(matrix_buffer, 1, 2, 2)
print(f"Processed tile values: {tile_result}")

# Show the modified matrix
modified_matrix = matrix_buffer.data.reshape(4, 8)
print("Matrix after tile processing:")
print(modified_matrix)
```

## Buffer View Factory

Use the factory function for convenient buffer creation:

```{pyodide}
# Create buffers using the factory function
data = np.array([1, 2, 3, 4, 5], dtype=np.int32)

# Simple buffer
buffer1 = make_buffer_view(
    data=data,
    buffer_size=len(data)
)

# Buffer with custom settings
buffer2 = make_buffer_view(
    data=data,
    buffer_size=len(data),
    address_space=AddressSpaceEnum.LDS,
    invalid_element_value=-1,
    invalid_element_use_numerical_zero=False
)

print(f"Buffer 1: {buffer1}")
print(f"Buffer 2: {buffer2}")
```

## Key Concepts

1. **Address Spaces**: Different memory hierarchies (Global, LDS, VGPR)
2. **Vectorized Access**: Efficient multi-element operations
3. **Bounds Checking**: Safe memory access with invalid element handling
4. **Memory Operations**: SET, ADD, ATOMIC operations
5. **GPU Memory Model**: Abstractions for GPU memory hierarchies

Buffer views provide the low-level foundation for efficient tensor operations by abstracting memory access patterns and supporting GPU-specific memory hierarchies.

## Next Steps

- **[Tensor Descriptor](tensor-descriptor.qmd)** - Learn how tensors use buffer views
- **[Tile Operations](tile-distribution.qmd)** - See buffer views in tile-based processing
- **[Tensor Coordinate](tensor-coordinate.qmd)** - Understand coordinate to memory mapping 