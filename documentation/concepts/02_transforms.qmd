---
title: "Individual Transform Operations"
format: 
  live-html:
    mermaid:
      theme: default
engine: jupyter
pyodide:
  packages:
    - micropip
---

The transformation engine is built from individual transform types that each handle specific coordinate conversions. Understanding these building blocks is essential for mastering the tile distribution system.

## ðŸŽ® **Interactive Exploration**

Explore transformation concepts interactively:

**[Tensor Transform Visualizer](https://ck.silobrain.com/tensor-transform/)** - Explore tensor descriptor transformations with visual graphs and mathematical formulas. See how data layouts change through various transformations.

## What Are Transforms?

Transform operations are the fundamental building blocks that convert coordinates between different dimensional spaces. Each transform operates between two coordinate spaces:

- **Lower Dimension Space**: The source coordinate system
- **Upper Dimension Space**: The target coordinate system

### Transform Direction

Transforms work bidirectionally:

- **Forward Transform**: Converts coordinates from the lower dimension to the upper dimension
- **Inverse Transform**: Converts coordinates back from the upper dimension to the lower dimension


### Zero-Copy Logical Operations

**Critical Understanding**: All transform operations happen in **logical coordinate space** only. There is **no data copying or movement** involved - this is a zero-copy system.

- **Data Storage**: The actual tensor data remains stored in memory in linear fashion, exactly as specified by the original tensor shape and strides at creation time
- **Logical Mapping**: Transforms only change how we interpret and access coordinates - they create different logical views of the same underlying data

```{=html}
<div class="mermaid">
graph TB
    subgraph "Tensor Coordinate Transformation"
        US["Lower Dimension Space<br/>Source coordinate system"]
        LS["Upper Dimension Space<br/>Target coordinate system"]
        
        DATA["Linear Data in Memory<br/>Layout determined by tensor<br/>shape & strides"]
    end
    
    US -->|"Forward Transform"| LS
    LS -->|"Inverse Transform"| US
    
    DATA -.->|"Same data,<br/>different views"| US
    DATA -.->|"Same data,<br/>different views"| LS
    
    style US fill:#e3f2fd,stroke:#1976d2,stroke-width:3px
    style LS fill:#fff3e0,stroke:#f57c00,stroke-width:3px
    style DATA fill:#f0f9ff,stroke:#0284c7,stroke-width:2px,stroke-dasharray: 5 5
</div>
```

```{=html}
<svg width="600" height="400" viewBox="0 0 600 400" xmlns="http://www.w3.org/2000/svg">
  <!-- Title -->
  <text x="300" y="25" text-anchor="middle" font-size="18" font-weight="bold" fill="#333">
    Physical Memory to Logical View Mapping
  </text>
  
  <!-- 2D Logical Tensor View (3x4 matrix) at top -->
  <g transform="translate(150, 60)">
    <text x="150" y="-10" text-anchor="middle" font-size="14" font-weight="bold" fill="#f57c00">
      2D Logical Tensor View (3Ã—4)
    </text>
    
    <!-- Row 0 -->
    <rect x="50" y="0" width="50" height="40" fill="#fff3e0" stroke="#f57c00" stroke-width="2"/>
    <text x="75" y="25" text-anchor="middle" font-size="12">(0,0)</text>
    
    <rect x="100" y="0" width="50" height="40" fill="#fff3e0" stroke="#f57c00" stroke-width="2"/>
    <text x="125" y="25" text-anchor="middle" font-size="12">(0,1)</text>
    
    <rect x="150" y="0" width="50" height="40" fill="#fff3e0" stroke="#f57c00" stroke-width="2"/>
    <text x="175" y="25" text-anchor="middle" font-size="12">(0,2)</text>
    
    <rect x="200" y="0" width="50" height="40" fill="#fff3e0" stroke="#f57c00" stroke-width="2"/>
    <text x="225" y="25" text-anchor="middle" font-size="12">(0,3)</text>
    
    <!-- Row 1 -->
    <rect x="50" y="40" width="50" height="40" fill="#fff3e0" stroke="#f57c00" stroke-width="2"/>
    <text x="75" y="65" text-anchor="middle" font-size="12">(1,0)</text>
    
    <rect x="100" y="40" width="50" height="40" fill="#fff3e0" stroke="#f57c00" stroke-width="2"/>
    <text x="125" y="65" text-anchor="middle" font-size="12">(1,1)</text>
    
    <rect x="150" y="40" width="50" height="40" fill="#ffcc80" stroke="#f57c00" stroke-width="3"/>
    <text x="175" y="65" text-anchor="middle" font-size="12" font-weight="bold">(1,2)</text>
    
    <rect x="200" y="40" width="50" height="40" fill="#fff3e0" stroke="#f57c00" stroke-width="2"/>
    <text x="225" y="65" text-anchor="middle" font-size="12">(1,3)</text>
    
    <!-- Row 2 -->
    <rect x="50" y="80" width="50" height="40" fill="#fff3e0" stroke="#f57c00" stroke-width="2"/>
    <text x="75" y="105" text-anchor="middle" font-size="12">(2,0)</text>
    
    <rect x="100" y="80" width="50" height="40" fill="#fff3e0" stroke="#f57c00" stroke-width="2"/>
    <text x="125" y="105" text-anchor="middle" font-size="12">(2,1)</text>
    
    <rect x="150" y="80" width="50" height="40" fill="#fff3e0" stroke="#f57c00" stroke-width="2"/>
    <text x="175" y="105" text-anchor="middle" font-size="12">(2,2)</text>
    
    <rect x="200" y="80" width="50" height="40" fill="#fff3e0" stroke="#f57c00" stroke-width="2"/>
    <text x="225" y="105" text-anchor="middle" font-size="12">(2,3)</text>
  </g>
  
  <!-- Arrows and labels -->
  <g>
    <!-- Down arrow from (1,2) -->
    <path d="M 325 195 Q 345 235 325 270" stroke="#666" stroke-width="2" fill="none" marker-end="url(#arrowdown)"/>
    <text x="355" y="230" font-size="12" fill="#666">calculate_lower_index()</text>
    <text x="355" y="245" font-size="11" fill="#666">(1,2) â†’ 1Ã—4+2 = 6</text>
    
    <!-- Up arrow to (1,2) -->
    <path d="M 305 270 Q 285 235 305 195" stroke="#666" stroke-width="2" fill="none" marker-end="url(#arrowup)"/>
    <text x="110" y="225" font-size="12" fill="#666">transformation name</text>
    <text x="110" y="240" font-size="12" fill="#666">specifies to_upper direction</text>
  </g>
  
  <!-- 1D Physical Memory Array at bottom -->
  <g transform="translate(30, 310)">
    <text x="270" y="-10" text-anchor="middle" font-size="14" font-weight="bold" fill="#1976d2">
      Linear Memory Array (1D)
    </text>
    
    <!-- Memory cells -->
    <rect x="0" y="0" width="45" height="40" fill="#e3f2fd" stroke="#1976d2" stroke-width="2"/>
    <text x="22.5" y="25" text-anchor="middle" font-size="12">[0]</text>
    
    <rect x="45" y="0" width="45" height="40" fill="#e3f2fd" stroke="#1976d2" stroke-width="2"/>
    <text x="67.5" y="25" text-anchor="middle" font-size="12">[1]</text>
    
    <rect x="90" y="0" width="45" height="40" fill="#e3f2fd" stroke="#1976d2" stroke-width="2"/>
    <text x="112.5" y="25" text-anchor="middle" font-size="12">[2]</text>
    
    <rect x="135" y="0" width="45" height="40" fill="#e3f2fd" stroke="#1976d2" stroke-width="2"/>
    <text x="157.5" y="25" text-anchor="middle" font-size="12">[3]</text>
    
    <rect x="180" y="0" width="45" height="40" fill="#e3f2fd" stroke="#1976d2" stroke-width="2"/>
    <text x="202.5" y="25" text-anchor="middle" font-size="12">[4]</text>
    
    <rect x="225" y="0" width="45" height="40" fill="#e3f2fd" stroke="#1976d2" stroke-width="2"/>
    <text x="247.5" y="25" text-anchor="middle" font-size="12">[5]</text>
    
    <rect x="270" y="0" width="45" height="40" fill="#90caf9" stroke="#1976d2" stroke-width="3"/>
    <text x="292.5" y="25" text-anchor="middle" font-size="12" font-weight="bold">[6]</text>
    
    <rect x="315" y="0" width="45" height="40" fill="#e3f2fd" stroke="#1976d2" stroke-width="2"/>
    <text x="337.5" y="25" text-anchor="middle" font-size="12">[7]</text>
    
    <rect x="360" y="0" width="45" height="40" fill="#e3f2fd" stroke="#1976d2" stroke-width="2"/>
    <text x="382.5" y="25" text-anchor="middle" font-size="12">[8]</text>
    
    <rect x="405" y="0" width="45" height="40" fill="#e3f2fd" stroke="#1976d2" stroke-width="2"/>
    <text x="427.5" y="25" text-anchor="middle" font-size="12">[9]</text>
    
    <rect x="450" y="0" width="45" height="40" fill="#e3f2fd" stroke="#1976d2" stroke-width="2"/>
    <text x="472.5" y="25" text-anchor="middle" font-size="12">[10]</text>
    
    <rect x="495" y="0" width="45" height="40" fill="#e3f2fd" stroke="#1976d2" stroke-width="2"/>
    <text x="517.5" y="25" text-anchor="middle" font-size="12">[11]</text>
  </g>
  
  <!-- Arrow definitions -->
  <defs>
    <marker id="arrowdown" markerWidth="8" markerHeight="8" refX="4" refY="8" orient="210">
      <path d="M 4,0 L 8,6 L 4,8 L 0,6 Z" fill="#666"/>
    </marker>
    <marker id="arrowup" markerWidth="8" markerHeight="8" refX="4" refY="0" orient="210">
      <path d="M 4,8 L 0,2 L 4,0 L 8,2 Z" fill="#666"/>
    </marker>
  </defs>
</svg>
```

### Index Calculation Operations

The transform system provides two fundamental operations for coordinate conversion:

- **`calculate_lower_index()`**: Takes a coordinate from the **upper dimension space** and transforms it to get the corresponding index/coordinate in the **lower dimension space**. This calculates where to find the actual tensor element using the transformed coordinate system.

- **`calculate_upper_index()`**: Takes a coordinate from the **lower dimension space** and transforms it back to get the corresponding coordinate in the **upper dimension space**. This performs the inverse transformation to recover the original coordinate representation.

These operations enable bidirectional navigation between different coordinate representations of the same underlying tensor data.

### Transform System Architecture

```{=html}
<div class="mermaid">
graph TB
    
    subgraph "Transform Types"
        EMB["EmbedTransform<br/>Linear â†’ Multi-D Strided"]
        UNM["MergeTransform<br/>Multi-D â†’ Linear"]
        MRG["UnmergeTransform<br/>Linear â†’ Multi-D"]
        REP["ReplicateTransform<br/>0D â†’ Multi-D Broadcast"]
        OFF["OffsetTransform<br/>Translation"]
        PAS["PassThroughTransform<br/>Identity"]
        PAD["PadTransform<br/>Boundaries"]
    end
    
    subgraph "Operations"
        FWD["Forward<br/>calculate_lower_index()"]
        BWD["Backward<br/>calculate_upper_index()"]
        UPD["Update<br/>update_lower_index()"]
    end
    
    EMB --> FWD
    UNM --> FWD
    MRG --> FWD
    REP --> FWD
    OFF --> FWD
    PAS --> FWD
    PAD --> FWD
    
    style FWD fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
</div>
```

```{pyodide}
#| echo: false
#| output: false
#| autorun: true

# Auto-install pythonck package
import micropip
await micropip.install("https://raw.githubusercontent.com/ghamarian/pythonck/master/documentation/pythonck-0.2.0-py3-none-any.whl")
```

## 1. MergeTransform

MergeTransform collapses multiple dimensions from the lower coordinate space into a single dimension in the upper coordinate space, effectively reducing the dimensionality of the tensor representation while preserving all data relationships.

```{=html}
<div class="mermaid">
graph TB
    subgraph "MergeTransform: Multi-D â†’ Linear"
        LS["Lower Coordinate Space<br/>2D: [4, 5]<br/>Coord: (2, 3)"]
        US["Upper Coordinate Space<br/>1D Linear<br/>Index: 13"]
        
        DATA["Same Tensor Data<br/>Layout: row-major<br/>Size: 20 elements"]
    end
    
    LS -->|"Forward Transform<br/>2Ã—5 + 3 = 13"| US
    US -->|"Inverse Transform<br/>13Ã·5=2, 13%5=3"| LS
    
    DATA -.->|"Multi-dimensional<br/>view"| LS
    DATA -.->|"Linear<br/>view"| US
    
    style LS fill:#e3f2fd,stroke:#1976d2,stroke-width:3px
    style US fill:#fff3e0,stroke:#f57c00,stroke-width:3px
    style DATA fill:#f0f9ff,stroke:#0284c7,stroke-width:2px,stroke-dasharray: 5 5
</div>
```

```{pyodide}
#| echo: true
#| output: true

import numpy as np
from pytensor.tensor_descriptor import MergeTransform
from pytensor.tensor_coordinate import MultiIndex

# Create MergeTransform for 4x5 tensor (20 elements total)
transform = MergeTransform(lengths=[4, 5])

# Forward: Lower (2D) â†’ Upper (1D) 
lower_2d = MultiIndex(size=2, values=[2, 3])
upper_linear = transform.calculate_upper_index(lower_2d)
print(f"2D coord {lower_2d.to_list()} â†’ Linear index {upper_linear.to_list()[0]}")
print(f"Calculation: {lower_2d.to_list()[0]}Ã—5 + {lower_2d.to_list()[1]} = {upper_linear.to_list()[0]}")

# Inverse: Upper (1D) â†’ Lower (2D)
upper_input = MultiIndex(size=1, values=[13])
lower_result = transform.calculate_lower_index(upper_input)
print(f"\nLinear index {upper_input.to_list()[0]} â†’ 2D coord {lower_result.to_list()}")
print(f"Calculation: 13 Ã· 5 = {lower_result.to_list()[0]} remainder {lower_result.to_list()[1]}")
```

#### C++ Implementation

```cpp
using namespace ck_tile;

// Create MergeTransform for 4x5 tensor (20 elements total)
auto transform = make_merge_transform(make_tuple(4, 5));

// Forward: Lower (2D) â†’ Upper (1D) - Manual calculation
int row = 2, col = 3;
int linear_index = row * 5 + col;  // Result: 13
printf("2D coord [%d, %d] â†’ Linear index %d\n", row, col, linear_index);
printf("Calculation: %dÃ—5 + %d = %d\n", row, col, linear_index);

// Inverse: Upper (1D) â†’ Lower (2D) - Using transform
multi_index<1> upper_coord;
upper_coord[number<0>{}] = 13;

multi_index<2> lower_coord;
transform.calculate_lower_index(lower_coord, upper_coord);

printf("Linear index %d â†’ 2D coord [%d, %d]\n", 
       static_cast<int>(upper_coord[number<0>{}]),
       static_cast<int>(lower_coord[number<0>{}]), 
       static_cast<int>(lower_coord[number<1>{}]));
printf("Calculation: 13 Ã· 5 = %d remainder %d\n",
       static_cast<int>(lower_coord[number<0>{}]),
       static_cast<int>(lower_coord[number<1>{}]));
```


## 2. UnmergeTransform

UnmergeTransform expands coordinates from a single dimension in the lower coordinate space into multiple dimensions in the upper coordinate space, effectively increasing the dimensionality of the tensor representation while preserving all data relationships.

```{=html}
<div class="mermaid">
graph TB
    subgraph "UnmergeTransform: Linear â†’ Multi-D"
        LS["Lower Coordinate Space<br/>1D Linear<br/>Index: 14"]
        US["Upper Coordinate Space<br/>3D: [3, 4, 2]<br/>Coord: (1, 3, 0)"]
        
        DATA["Same Tensor Data<br/>Layout: row-major<br/>Size: 24 elements"]
    end
    
    LS -->|"Forward Transform<br/>14 = 1Ã—8 + 3Ã—2 + 0"| US
    US -->|"Inverse Transform<br/>linearize back"| LS
    
    DATA -.->|"Linear<br/>view"| LS
    DATA -.->|"Multi-dimensional<br/>view"| US
    
    style LS fill:#e3f2fd,stroke:#1976d2,stroke-width:3px
    style US fill:#fff3e0,stroke:#f57c00,stroke-width:3px
    style DATA fill:#f0f9ff,stroke:#0284c7,stroke-width:2px,stroke-dasharray: 5 5
</div>
```

```{pyodide}
#| echo: true
#| output: true

import numpy as np
from pytensor.tensor_descriptor import UnmergeTransform
from pytensor.tensor_coordinate import MultiIndex

# Create UnmergeTransform for 3x4x2 tensor (24 elements total)
transform = UnmergeTransform(lengths=[3, 4, 2])

# Forward: Lower (1D) â†’ Upper (3D)
lower_linear = MultiIndex(size=1, values=[14])
upper_3d = transform.calculate_upper_index(lower_linear)
print(f"Linear index {lower_linear.to_list()[0]} â†’ 3D coord {upper_3d.to_list()}")
print(f"Calculation: 14 = {upper_3d.to_list()[0]}Ã—8 + {upper_3d.to_list()[1]}Ã—2 + {upper_3d.to_list()[2]}")

# Inverse: Upper (3D) â†’ Lower (1D)
upper_input = MultiIndex(size=3, values=[1, 3, 0])
lower_result = transform.calculate_lower_index(upper_input)
print(f"\n3D coord {upper_input.to_list()} â†’ Linear index {lower_result.to_list()[0]}")
print(f"Calculation: {upper_input.to_list()[0]}Ã—8 + {upper_input.to_list()[1]}Ã—2 + {upper_input.to_list()[2]} = {lower_result.to_list()[0]}")
```

#### C++ Implementation

```cpp
using namespace ck_tile;

// Create UnmergeTransform for 3x4x2 tensor (24 elements total)
auto transform = make_unmerge_transform(make_tuple(3, 4, 2));

// Forward: Lower (1D) â†’ Upper (3D) - Manual calculation
int linear_index = 14;
int dim0 = linear_index / (4 * 2);      // 14 / 8 = 1
int remainder = linear_index % (4 * 2);  // 14 % 8 = 6
int dim1 = remainder / 2;               // 6 / 2 = 3
int dim2 = remainder % 2;               // 6 % 2 = 0

printf("Linear index %d â†’ 3D coord [%d, %d, %d]\n", 
       linear_index, dim0, dim1, dim2);
printf("Calculation: 14 = %dÃ—8 + %dÃ—2 + %d\n", dim0, dim1, dim2);

// Inverse: Upper (3D) â†’ Lower (1D) - Using transform
multi_index<3> upper_coord;
upper_coord[number<0>{}] = 1;
upper_coord[number<1>{}] = 3;
upper_coord[number<2>{}] = 0;

multi_index<1> lower_coord;
transform.calculate_lower_index(lower_coord, upper_coord);

printf("3D coord [%d, %d, %d] â†’ Linear index %d\n",
       static_cast<int>(upper_coord[number<0>{}]),
       static_cast<int>(upper_coord[number<1>{}]),
       static_cast<int>(upper_coord[number<2>{}]),
       static_cast<int>(lower_coord[number<0>{}]));
printf("Calculation: %dÃ—8 + %dÃ—2 + %d = %d\n",
       static_cast<int>(upper_coord[number<0>{}]),
       static_cast<int>(upper_coord[number<1>{}]),
       static_cast<int>(upper_coord[number<2>{}]),
       static_cast<int>(lower_coord[number<0>{}]));
```


## 3. EmbedTransform

EmbedTransform expands linear indices from the lower coordinate space into multi-dimensional coordinates in the upper coordinate space using configurable strides, enabling flexible strided tensor layouts and sub-tensor views within larger buffers.

```{=html}
<div class="mermaid">
graph TB
    subgraph "EmbedTransform: Linear â†’ Multi-D Strided"
        LS["Lower Coordinate Space<br/>1D Linear<br/>Index: 14"]
        US["Upper Coordinate Space<br/>2D: [2, 3]<br/>Coord: (1, 2)"]
        
        DATA["Linear Buffer in Memory"]
    end
    
    LS -->|"Forward Transform <br/>Strides: [12, 1] <br/>14 Ã· 12 = 1, 14 % 12 = 2"| US
    US -->|"Inverse Transform<br/>1Ã—12 + 2Ã—1 = 14"| LS
    
    DATA -.->|"Linear<br/>index view"| LS
    DATA -.->|"Multi-dimensional<br/>strided view"| US
    
    style LS fill:#e3f2fd,stroke:#1976d2,stroke-width:3px
    style US fill:#fff3e0,stroke:#f57c00,stroke-width:3px
    style DATA fill:#f0f9ff,stroke:#0284c7,stroke-width:2px,stroke-dasharray: 5 5
</div>
```

```{pyodide}
#| echo: true
#| output: true

import numpy as np
from pytensor.tensor_descriptor import EmbedTransform
from pytensor.tensor_coordinate import MultiIndex

# Create EmbedTransform for 2x3 tensor with custom strides  
transform = EmbedTransform(
    lengths=[2, 3],     # Shape: 2 rows, 3 columns
    strides=[12, 1]     # Row stride=12, column stride=1
)

# Forward: Lower (1D) â†’ Upper (2D)
lower_linear = MultiIndex(size=1, values=[14])
upper_coord = transform.calculate_upper_index(lower_linear)
print(f"Linear index {lower_linear.to_list()[0]} â†’ 2D coord {upper_coord.to_list()}")
print(f"Calculation: 14 Ã· 12 = {upper_coord.to_list()[0]}, remainder = {upper_coord.to_list()[1]}")

# Inverse: Upper (2D) â†’ Lower (1D)
upper_input = MultiIndex(size=2, values=[1, 2])
lower_result = transform.calculate_lower_index(upper_input)
print(f"\n2D coord {upper_input.to_list()} â†’ Linear index {lower_result.to_list()[0]}")
print(f"Calculation: {upper_input.to_list()[0]}Ã—12 + {upper_input.to_list()[1]}Ã—1 = {lower_result.to_list()[0]}")
```

#### C++ Implementation

```cpp
using namespace ck_tile;

// Create embed transform for 2x3 tensor with strides [12, 1]
auto transform = make_embed_transform(make_tuple(2, 3), make_tuple(12, 1));

// Forward: Linear â†’ 2D (Manual calculation)
int linear_idx = 14;
int row = linear_idx / 12;        // 14 / 12 = 1
int remainder = linear_idx % 12;  // 14 % 12 = 2  
int col = remainder / 1;          // 2 / 1 = 2
printf("Linear index %d â†’ 2D coord [%d, %d]\n", linear_idx, row, col);

// Inverse: 2D â†’ Linear (Using transform)
multi_index<2> upper_coord;
upper_coord[number<0>{}] = 1;
upper_coord[number<1>{}] = 2;

multi_index<1> lower_coord;
transform.calculate_lower_index(lower_coord, upper_coord);
printf("2D coord [%d, %d] â†’ Linear index %d\n",
       static_cast<int>(upper_coord[number<0>{}]),
       static_cast<int>(upper_coord[number<1>{}]),
       static_cast<int>(lower_coord[number<0>{}]));
```

## 4. ReplicateTransform

ReplicateTransform creates a higher-dimensional tensor by replicating (broadcasting) a lower-dimensional tensor. It's essentially a broadcasting operation that takes a tensor with fewer dimensions and logically replicates it across new dimensions without data duplication. An example is taking a scalar (0-dimensional) input and broadcasting it across multiple dimensions, enabling efficient broadcasting patterns where a single value appears at every position in a multi-dimensional coordinate space.

```{=html}
<div class="mermaid">
graph TB
    subgraph "ReplicateTransform: 0D â†’ Multi-D Broadcasting"
        LS["Lower Coordinate Space<br/>0D: Scalar<br/>Empty coordinate []"]
        US["Upper Coordinate Space<br/>2D: [3, 4]<br/>All coords: (i, j)"]
        
        DATA["Single Scalar Value"]
    end
    
    LS -->|"Forward Transform<br/>[] â†’ (i,j) for any i,j"| US
    US -->|"Inverse Transform<br/>(i,j) â†’ [] for any i,j"| LS
    
    DATA -.->|"One scalar<br/>value"| LS
    DATA -.->|"Broadcasted view<br/>at all positions"| US
    
    style LS fill:#e3f2fd,stroke:#1976d2,stroke-width:3px
    style US fill:#fff3e0,stroke:#f57c00,stroke-width:3px
    style DATA fill:#f0f9ff,stroke:#0284c7,stroke-width:2px,stroke-dasharray: 5 5
</div>
```

```{pyodide}
#| echo: true
#| output: true

import numpy as np
from pytensor.tensor_descriptor import ReplicateTransform
from pytensor.tensor_coordinate import MultiIndex

# Create ReplicateTransform for 3x4 broadcasted dimensions
transform = ReplicateTransform(upper_lengths=[3, 4])

print(f"Upper lengths: {transform.upper_lengths}")
print(f"Lower dimensions: {transform.get_num_of_lower_dimension()}")
print(f"Upper dimensions: {transform.get_num_of_upper_dimension()}")

# Forward: Lower (0D) â†’ Upper (2D) - all map to zeros
lower_empty = MultiIndex(size=0, values=[])
upper_coord = transform.calculate_upper_index(lower_empty)
print(f"\nForward: Empty lower â†’ Upper {upper_coord.to_list()}")

# Inverse: Upper (2D) â†’ Lower (0D) - all map to empty
test_coordinates = [(0, 0), (1, 2), (2, 3)]
for coord in test_coordinates:
    upper_input = MultiIndex(size=2, values=list(coord))
    lower_result = transform.calculate_lower_index(upper_input)
    print(f"Upper {upper_input.to_list()} â†’ Lower {lower_result.to_list()} (empty)")

```

#### C++ Implementation

```cpp
using namespace ck_tile;

// Create replicate transform for 3x4 broadcasting
auto transform = make_replicate_transform(make_tuple(3, 4));

// Inverse: Upper (2D) â†’ Lower (0D) - Using transform
// Any 2D coordinate maps to empty scalar coordinate
multi_index<2> upper_coord;
upper_coord[number<0>{}] = 1;
upper_coord[number<1>{}] = 2;

multi_index<0> lower_coord;  // Empty coordinate (0 dimensions)
transform.calculate_lower_index(lower_coord, upper_coord);
printf("2D [%d, %d] â†’ Empty scalar [] (always empty)\n",
       static_cast<int>(upper_coord[number<0>{}]),
       static_cast<int>(upper_coord[number<1>{}]));

// Forward: Scalar â†’ 2D (Conceptual - no coordinate calculation needed)
// Broadcasting: Single scalar value appears at ALL positions
printf("Broadcasting: Scalar value appears at every [i,j] where 0â‰¤i<3, 0â‰¤j<4\n");
printf("Total positions: 3Ã—4 = 12 positions, all contain same scalar value\n");

// Test multiple coordinates - all map to empty scalar
int test_coords[][2] = {{0, 0}, {1, 2}, {2, 3}};
for(int i = 0; i < 3; i++)
{
    multi_index<2> test_upper;
    test_upper[number<0>{}] = test_coords[i][0];
    test_upper[number<1>{}] = test_coords[i][1];
    
    multi_index<0> test_lower;
    transform.calculate_lower_index(test_lower, test_upper);
    printf("2D [%d, %d] â†’ Empty scalar []\n", 
           test_coords[i][0], test_coords[i][1]);
}
```


## 5. OffsetTransform

OffsetTransform shifts coordinates by a fixed offset, creating a translated view of the coordinate space. It performs simple translation operations where each coordinate in the upper space is mapped to a coordinate in the lower space by adding a constant offset.

```{=html}
<div class="mermaid">
graph TB
    subgraph "OffsetTransform: 1D â†’ 1D Translation"
        LS["Lower Coordinate Space<br/>1D: [0, 63]<br/>Coord: index + offset"]
        US["Upper Coordinate Space<br/>1D: [0, 47]<br/>Coord: index"]
        
        DATA["Linear Buffer in Memory"]
    end
    
    LS -->|"Forward Transform<br/>idx â†’ idx + 16"| US
    US -->|"Inverse Transform<br/>idx + 16 â†’ idx"| LS
    
    DATA -.->|"Lower<br/>view"| LS
    DATA -.->|"Upper<br/>view"| US
    
    style LS fill:#e3f2fd,stroke:#1976d2,stroke-width:3px
    style US fill:#fff3e0,stroke:#f57c00,stroke-width:3px
    style DATA fill:#f0f9ff,stroke:#0284c7,stroke-width:2px,stroke-dasharray: 5 5
</div>
```

```{pyodide}
#| echo: true
#| output: true
import numpy as np
from pytensor.tensor_descriptor import OffsetTransform
from pytensor.tensor_coordinate import MultiIndex

# Create OffsetTransform for coordinate translation
# CK Tile offset: lower = upper + offset (adds offset to coordinates)
transform = OffsetTransform(
    element_space_size=48,  # Size of the coordinate space (48 elements)
    offset=16              # Offset value to add
)

# Inverse: Upper (original) â†’ Lower (translated) using transform
upper_coord = MultiIndex(size=1, values=[5])
lower_coord = transform.calculate_lower_index(upper_coord)
print(f"Original index {upper_coord.to_list()[0]} â†’ Translated index {lower_coord.to_list()[0]}")
print(f"Calculation: {upper_coord.to_list()[0]} + {16} = {lower_coord.to_list()[0]}")

# Forward: Lower (translated) â†’ Upper (original) using transform  
lower_input = MultiIndex(size=1, values=[21])
upper_result = transform.calculate_upper_index(lower_input)
print(f"\nTranslated index {lower_input.to_list()[0]} â†’ Original index {upper_result.to_list()[0]}")
print(f"Calculation: {lower_input.to_list()[0]} - {16} = {upper_result.to_list()[0]}")

# Show additional examples
print("\nAdditional offset examples:")
test_original_indices = [0, 10, 20, 47]  # Test boundary and middle values
for idx in test_original_indices:
    original = MultiIndex(size=1, values=[idx])
    translated = transform.calculate_lower_index(original)
    print(f"  Original {idx} â†’ Translated {translated.to_list()[0]} (offset +{16})")

print("\nOffset transform behavior:")
print(f"  Maps original space [0, 47] to translated space [16, 63]")
print("  Used for translating logical coordinates to buffer positions")
print("  Essential for tile-based algorithms and memory management")
```

#### C++ Implementation

```cpp
using namespace ck_tile;

// Create offset transform for coordinate translation
// CK Tile formula: lower = upper + offset
auto transform = make_offset_transform(48, 16);

// Using Transform: Original â†’ Translated (adds offset)
multi_index<1> upper_coord;
upper_coord[number<0>{}] = 5;  // Original index 5

multi_index<1> lower_coord;
transform.calculate_lower_index(lower_coord, upper_coord);
printf("Original index %d â†’ Translated index %d
",
       static_cast<int>(upper_coord[number<0>{}]),
       static_cast<int>(lower_coord[number<0>{}]));
printf("Calculation: %d + 16 = %d
",
       static_cast<int>(upper_coord[number<0>{}]),
       static_cast<int>(lower_coord[number<0>{}]));

// Manual Reverse: Translated â†’ Original (subtract offset)
int translated_idx = 21;
int original_idx = translated_idx - 16;
printf("Translated index %d â†’ Original index %d
", translated_idx, original_idx);

// Test multiple coordinates
int test_indices[] = {0, 10, 20, 47};
for(int i = 0; i < 4; i++)
{
    multi_index<1> test_upper;
    test_upper[number<0>{}] = test_indices[i];
    
    multi_index<1> test_lower;
    transform.calculate_lower_index(test_lower, test_upper);
    printf("Original %d â†’ Translated %d
", 
           test_indices[i], static_cast<int>(test_lower[number<0>{}]));
}
```

## 6. PassThroughTransform - Identity

No-op transform that passes coordinates unchanged. The PassThrough transform is the simplest coordinate transformation in CK Tile, implementing a perfect identity mapping where input coordinates are passed through unchanged to the output. This transform is essential as a placeholder in transformation chains and for dimensions that require no modification.

```{=html}
<div class="mermaid">
graph TB
    subgraph "PassThroughTransform: 1D â†’ 1D Identity"
        LS["Lower Coordinate Space<br/>1D: [0, 59]<br/>Coord: index"]
        US["Upper Coordinate Space<br/>1D: [0, 59]<br/>Coord: index"]
        
        DATA["Linear Buffer in Memory"]
    end
    
    LS -.->|"Perfect Identity<br/>idx â†’ idx"| US
    US -.->|"Perfect Identity<br/>idx â†’ idx"| LS
    
    DATA -->|"Same buffer<br/>same view"| LS
    DATA -->|"Same buffer<br/>same view"| US
    
    style LS fill:#e8f5e8,stroke:#2e7d32,stroke-width:3px
    style US fill:#e8f5e8,stroke:#2e7d32,stroke-width:3px
    style DATA fill:#f0f9ff,stroke:#0284c7,stroke-width:2px,stroke-dasharray: 5 5
</div>
```

```{pyodide}
#| echo: true
#| output: true

from pytensor.tensor_descriptor import PassThroughTransform
from pytensor.tensor_coordinate import MultiIndex

length = 60

transform = PassThroughTransform(length=length)

print(f"Length: {length}")

# Forward: Upper â†’ Lower (identity)
upper_coord = MultiIndex(size=1, values=[25])
lower_coord = transform.calculate_lower_index(upper_coord)
print(f"\nForward: {upper_coord.to_list()} â†’ {lower_coord.to_list()} (unchanged)")

# Reverse: Lower â†’ Upper (identity)
lower_input = MultiIndex(size=1, values=[42])
upper_result = transform.calculate_upper_index(lower_input)
print(f"Reverse: {lower_input.to_list()} â†’ {upper_result.to_list()} (unchanged)")
```

#### C++ Implementation

```cpp
using namespace ck_tile;

// Identity transform - no change
int length = 60;

auto transform = make_pass_through_transform(length);

printf("Length: %d\n", length);

// Forward: Upper â†’ Lower (identity)
multi_index<1> upper_coord;
upper_coord[number<0>{}] = 25;

multi_index<1> lower_coord;
transform.calculate_lower_index(lower_coord, upper_coord);

printf("\nForward: [%d] â†’ [%d] (unchanged)\n",
       static_cast<int>(upper_coord[number<0>{}]),
       static_cast<int>(lower_coord[number<0>{}]));

// Reverse: Lower â†’ Upper (identity)  
multi_index<1> lower_input;
lower_input[number<0>{}] = 42;

multi_index<1> upper_result;
// Note: PassThrough is bidirectional identity, so we can use same function
transform.calculate_lower_index(upper_result, lower_input);

printf("Reverse: [%d] â†’ [%d] (unchanged)\n",
       static_cast<int>(lower_input[number<0>{}]),
       static_cast<int>(upper_result[number<0>{}]));
```

## 7. PadTransform

PadTransform adds padding to tensor dimensions, mapping coordinates from upper dimension space (with padding) to lower dimension space (original data).

```{=html}
<div class="mermaid">
graph TB
    subgraph "PadTransform: 1D â†’ 1D with Padding"
        LS["Lower Coordinate Space<br/>1D: [0, 2] (original data)"]
        US["Upper Coordinate Space<br/>1D: [0, 4] (with padding)"]
        
        DATA["Tensor Data in Memory"]
    end
    
    LS -->|"Forward Transform<br/>idx + left_pad"| US
    US -->|"Inverse Transform<br/>idx - left_pad"| LS
    
    DATA -.->|"Original view"| LS
    DATA -.->|"Padded view"| US
    
    style LS fill:#e3f2fd,stroke:#1976d2,stroke-width:3px
    style US fill:#fff3e0,stroke:#f57c00,stroke-width:3px
    style DATA fill:#f0f9ff,stroke:#0284c7,stroke-width:2px,stroke-dasharray: 5 5
</div>
```

```{pyodide}
#| echo: true
#| output: true

from pytensor.tensor_descriptor import PadTransform
from pytensor.tensor_coordinate import MultiIndex

# PadTransform for coordinate padding
low_length = 3        # Original dimension length
left_pad = 1          # Padding on left
right_pad = 1         # Padding on right

transform = PadTransform(
    lower_length=low_length,
    left_pad=left_pad,
    right_pad=right_pad
)

print(f"Low length: {low_length}")
print(f"Left pad: {left_pad}")
print(f"Right pad: {right_pad}")
print(f"Upper length: {low_length + left_pad + right_pad} (total with padding)")

# Test coordinate mapping
test_coords = [0, 1, 2, 3, 4]
for idx in test_coords:
    upper = MultiIndex(size=1, values=[idx])
    lower = transform.calculate_lower_index(upper)
    adjusted_idx = lower.to_list()[0]
    is_valid = 0 <= adjusted_idx < low_length
    print(f"Upper {idx} â†’ Lower {adjusted_idx} ({'valid' if is_valid else 'padding'})")
```

#### C++ Implementation

```cpp
using namespace ck_tile;

// PadTransform for coordinate padding
int low_length = 3;   // Original dimension length
int left_pad = 1;     // Padding on left
int right_pad = 1;    // Padding on right

auto transform = make_pad_transform(low_length, left_pad, right_pad);

printf("Low length: %d\n", low_length);
printf("Left pad: %d\n", left_pad);
printf("Right pad: %d\n", right_pad);
printf("Upper length: %d (total with padding)\n", low_length + left_pad + right_pad);

// Test coordinate mapping
int test_coords[] = {0, 1, 2, 3, 4};
for(int i = 0; i < 5; i++)
{
    multi_index<1> upper;
    upper[number<0>{}] = test_coords[i];
    
    multi_index<1> lower;
    transform.calculate_lower_index(lower, upper);
    
    int adjusted_idx = static_cast<int>(lower[number<0>{}]);
    bool is_valid = (adjusted_idx >= 0 && adjusted_idx < low_length);
    
    printf("Upper %d â†’ Lower %d (%s)\n", 
           test_coords[i], adjusted_idx, 
           is_valid ? "valid" : "padding");
}
```

## 8. XorTransform

XorTransform applies a 2D XOR mapping for specialized memory access patterns. It performs XOR operations on coordinates to create transformed memory layouts for specific algorithmic optimizations.

```{=html}
<div class="mermaid">
graph TB
    subgraph "XorTransform: 2D â†’ 2D XOR Mapping"
        LS["Lower Coordinate Space<br/>2D: [4, 8]<br/>XOR-transformed coords"]
        US["Upper Coordinate Space<br/>2D: [4, 8]<br/>Normal coords"]
        
        DATA["Same Tensor Data"]
    end
    
    LS -->|"Forward Transform<br/>apply XOR reverse"| US
    US -->|"Inverse Transform<br/>apply XOR mapping"| LS
    
    DATA -.->|"XOR pattern<br/>view"| LS
    DATA -.->|"Normal<br/>view"| US
    
    style LS fill:#e3f2fd,stroke:#1976d2,stroke-width:3px
    style US fill:#fff3e0,stroke:#f57c00,stroke-width:3px
    style DATA fill:#f0f9ff,stroke:#0284c7,stroke-width:2px,stroke-dasharray: 5 5
</div>
```

## 9. SliceTransform

SliceTransform extracts a sub-region from a tensor dimension.

```{=html}
<div class="mermaid">
graph TB
    subgraph "SliceTransform: 1D â†’ 1D Sub-region"
        LS["Lower Coordinate Space<br/>1D: [0, 9] (original range)"]
        US["Upper Coordinate Space<br/>1D: [0, 4] (slice range)"]
        
        DATA["Tensor Data in Memory"]
    end
    
    LS -->|"Forward Transform<br/>idx + slice_begin"| US
    US -->|"Inverse Transform<br/>idx - slice_begin"| LS
    
    DATA -.->|"Full tensor<br/>view"| LS
    DATA -.->|"Sub-region<br/>view"| US
    
    style LS fill:#e3f2fd,stroke:#1976d2,stroke-width:3px
    style US fill:#fff3e0,stroke:#f57c00,stroke-width:3px
    style DATA fill:#f0f9ff,stroke:#0284c7,stroke-width:2px,stroke-dasharray: 5 5
</div>
```

## 10. ModuloTransform

ModuloTransform applies cyclic wrapping to coordinates using modulo operations.

```{=html}
<div class="mermaid">
graph TB
    subgraph "ModuloTransform: 1D â†’ 1D Cyclic"
        LS["Lower Coordinate Space<br/>1D: [0, 3] (modulus range)"]
        US["Upper Coordinate Space<br/>1D: [0, 15] (full range)"]
        
        DATA["Tensor Data in Memory"]
    end
    
    LS -->|"Forward Transform<br/>idx * cycle_count"| US
    US -->|"Inverse Transform<br/>idx % modulus"| LS
    
    DATA -.->|" "| LS
    DATA -.->|" "| US
    
    style LS fill:#e3f2fd,stroke:#1976d2,stroke-width:3px
    style US fill:#fff3e0,stroke:#f57c00,stroke-width:3px
    style DATA fill:#f0f9ff,stroke:#0284c7,stroke-width:2px,stroke-dasharray: 5 5
</div>
```

## Summary

Individual transforms provide:

- **Modularity**: Each transform does one thing well
- **Composability**: Chain transforms for complex mappings
- **Efficiency**: Compile-time optimization in C++
- **Flexibility**: Handle any coordinate conversion need

Understanding these building blocks enables you to:

1. Create custom tensor views
2. Implement efficient data access patterns
3. Handle padding and boundaries correctly
4. Optimize memory layouts for GPU access

The C++ implementations in Composable Kernel provide:

- Zero-overhead abstractions through templates
- Compile-time composition and optimization
- Support for complex coordinate transformations
- Integration with GPU kernel generation
