---
title: "Individual Transform Coordinates"
format:
  live-html:
    mermaid:
      theme: default
engine: jupyter
pyodide:
  packages:
    - micropip
---

Before diving into transforms and adaptors, we need to understand the basic coordinate system. MultiIndex is the fundamental building block used throughout the pytensor system. It is a container in CKTile that extends the c++ array with additional operations for multi-dimensional indexing.

## What is MultiIndex?

MultiIndex represents a position in N-dimensional space - think of it as GPS coordinates for tensors:

- **Simple**: Just stores a list of integers
- **Fundamental**: Used by all transforms, adaptors, and descriptors
- **Flexible**: Supports copying, comparison, and modification

### MultiIndex Architecture

```{=html}
<div class="mermaid">
graph TB
    subgraph "MultiIndex Structure"
        MI["MultiIndex<br/>Container for N integers"]
        D0["Dimension 0"]
        D1["Dimension 1"]
        D2["Dimension 2"]
        DN["Dimension N-1"]
    end

    subgraph "Usage Context"
        T["Transforms<br/>"]
        A["Adaptors<br/>"]
        TV["Tensors<br/>"]
    end

    MI --> D0
    MI --> D1
    MI --> D2
    MI --> DN

    T --> MI
    A --> MI
    TV --> MI

    style MI fill:#f3e5f5,stroke:#7b1fa2,stroke-width:3px
    style D0 fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    style D1 fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    style D2 fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    style DN fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    style T fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
    style A fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    style TV fill:#ffebee,stroke:#d32f2f,stroke-width:2px
</div>
```

```{pyodide}
#| echo: false
#| output: false
#| autorun: true

# Auto-install pythonck package
import micropip
await micropip.install("https://raw.githubusercontent.com/ghamarian/pythonck/master/documentation/pythonck-0.1.0-py3-none-any.whl")

```

## Creating and Using MultiIndex

```{pyodide}
#| echo: true
#| output: true

import numpy as np
from pytensor.tensor_coordinate import MultiIndex

# Create a 3D coordinate
coord = MultiIndex(size=3, values=[1, 2, 3])
print(f"3D coordinate: {coord}")
print(f"As list: {coord.to_list()}")

# Create a 2D coordinate for matrix access
matrix_coord = MultiIndex(size=2, values=[0, 1])
print(f"\nMatrix coordinate: {matrix_coord}")

# Create uninitialized coordinate (all zeros)
empty_coord = MultiIndex(size=4)
print(f"\nEmpty 4D coordinate: {empty_coord}")
```

### Accessing and Modifying Coordinates

```{pyodide}
#| echo: true
#| output: true

# Create coordinate
coord = MultiIndex(size=3, values=[10, 20, 30])
print(f"Original: {coord}")

# Access individual dimensions
print(f"\nDimension 0 (X): {coord[0]}")
print(f"Dimension 1 (Y): {coord[1]}")
print(f"Dimension 2 (Z): {coord[2]}")

# Modify dimensions
coord[0] = 15
coord[1] = 25
print(f"\nAfter modification: {coord}")

# Iterate through dimensions
print("\nIterating through dimensions:")
for i, value in enumerate(coord):
    print(f"  Dimension {i}: {value}")
```


### C++ Implementation Reference

**File**: `include/ck_tile/core/container/multi_index.hpp`

```cpp
#include <ck_tile/core/container/multi_index.hpp>

__device__ void example_multiindex_usage()
{
    // Create 3D coordinate with runtime values
    auto coord = make_multi_index(1, 2, 3);

    // Access dimensions (runtime)
    auto x = coord[0];  // Returns 1
    auto y = coord[1];  // Returns 2
    auto z = coord[2];  // Returns 3

    // For compile-time coordinates, use number<>
    auto coord_static = make_multi_index(number<1>{}, number<2>{}, number<3>{});

    // Create from tuple
    auto shape = make_tuple(128, 256, 64);
    auto coord2 = to_multi_index(shape);

    // Modify coordinate
    auto new_coord = coord;
    new_coord.set<0>(number<5>{});  // Set X to 5

    // Use in tensor access
    auto tensor = make_naive_tensor_view<address_space_enum::global>(
        data_ptr, shape, strides
    );
    // Create tensor coordinate for access
    auto tensor_coord = make_tensor_coordinate(
        tensor.get_tensor_descriptor(), coord
    );
    float value = tensor.get_vectorized_elements<float>(tensor_coord, 0);
}
```

## MultiIndex in Transforms

MultiIndex serves as the common currency between different coordinate spaces:

```{=html}
<div class="mermaid">
flowchart TB
    subgraph CF ["Coordinate Flow"]
        direction LR
        UI["User Input<br/>[1, 2, 3]"] --> MI["MultiIndex<br/>Storage"]
        MI --> TR["Transform<br/>Processing"]
        TR --> MO["MultiIndex<br/>Output"]
        MO --> TA["Tensor Access<br/>element(coord)"]
    end

    subgraph EX ["Example: 3D Tensor Access"]
        direction LR
        T3D["3D Tensor<br/>shape=[4,5,6]"] --> COORD["MultiIndex(3, [1,2,3])"]
        COORD --> ELEM["Element at<br/>position [1,2,3]"]
    end

    style UI fill:#e0e7ff,stroke:#4338ca,stroke-width:2px
    style MI fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    style MO fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    style COORD fill:#fff3e0,stroke:#f57c00,stroke-width:2px
</div>
```

<!--

## MultiIndex Patterns

### Pattern 1: Iteration

```{pyodide}
#| echo: true
#| output: true

def iterate_2d_tensor(rows, cols):
    """Demonstrate how to iterate through a 2D tensor using MultiIndex"""
    print(f"Iterating through {rows}x{cols} tensor:")

    for i in range(rows):
        for j in range(cols):
            coord = MultiIndex(size=2, values=[i, j])
            print(f"  {coord.to_list()}", end=" ")
        print()  # New line after each row

iterate_2d_tensor(3, 4)
```

### Pattern 2: Boundary Checking

```{pyodide}
#| echo: true
#| output: true

def is_valid_coordinate(coord, shape):
    """Check if coordinate is within tensor bounds"""
    if len(coord.to_list()) != len(shape):
        return False

    for i, (c, s) in enumerate(zip(coord, shape)):
        if c < 0 or c >= s:
            return False
    return True

# Test boundary checking
shape = [4, 5, 6]
test_coords = [
    [1, 2, 3],  # Valid
    [3, 4, 5],  # Valid
    [4, 0, 0],  # Invalid: dimension 0 out of bounds
    [0, 5, 0],  # Invalid: dimension 1 out of bounds
    [1, 2],     # Invalid: wrong number of dimensions
]

for coord_values in test_coords:
    if len(coord_values) == len(shape):
        coord = MultiIndex(size=len(shape), values=coord_values)
        valid = is_valid_coordinate(coord, shape)
        print(f"Coordinate {coord_values} is {'valid' if valid else 'invalid'}")
    else:
        print(f"Coordinate {coord_values} is invalid (wrong dimensions)")
```

### Pattern 3: Transform Chaining

```{pyodide}
#| echo: true
#| output: true

# Simulate how transforms modify coordinates
def apply_offset(coord, offset):
    """Apply offset transform to coordinate"""
    result = coord.copy()
    for i in range(len(coord.to_list())):
        result[i] = coord[i] + offset[i]
    return result

def apply_stride(coord, strides):
    """Apply stride transform to coordinate"""
    result = coord.copy()
    for i in range(len(coord.to_list())):
        result[i] = coord[i] * strides[i]
    return result

# Example transform chain
original = MultiIndex(size=3, values=[1, 2, 3])
print(f"Original coordinate: {original}")

# Apply transforms
offset = [10, 20, 30]
after_offset = apply_offset(original, offset)
print(f"After offset {offset}: {after_offset}")

strides = [4, 1, 1]
after_stride = apply_stride(after_offset, strides)
print(f"After stride {strides}: {after_stride}")
```
-->

## Summary

MultiIndex is the foundation of the coordinate system:

- **Simple abstraction**: Just a container for N integers
- **Universal usage**: Every transform and adaptor uses MultiIndex
- **Type-safe in C++**: Compile-time size and bounds checking
- **Flexible in Python**: Dynamic size for experimentation

Understanding MultiIndex is crucial before moving to transforms and adaptors, as they all operate on these coordinate containers.
