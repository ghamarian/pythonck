<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Convolution Implementation with Tensor Descriptors – Tile Distribution Documentation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-4323a5a257e38fe2402c5f8dc357a0be.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-sidebar docked fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../concepts/02_tensor_coordinates.html">Transformation Engine</a></li><li class="breadcrumb-item"><a href="../concepts/02_convolution_example.html">Convolution Implementation with Tensor Descriptors</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Tile Distribution Documentation</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Getting Started</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tile Distribution Documentation</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Foundation</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../concepts/00_introduction_motivation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction and Motivation - Why Tile Distribution Matters</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../concepts/01_buffer_view.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Buffer Views - Raw Memory Access</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../concepts/01_tensor_view.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tensor Views - Multi-Dimensional Structure</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Transformation Engine</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../concepts/02_tensor_coordinates.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Basic Coordinates</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../concepts/02_transforms.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Individual Transforms</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../concepts/02_adaptors.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tensor Adaptors - Chaining Transformations</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../concepts/02_descriptors.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tensor Descriptors - Complete Tensor Specifications</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../concepts/02_convolution_example.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Convolution Implementation with Tensor Descriptors</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../concepts/02_coordinate_movement.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Advanced Coordinate Operations</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true">
 <span class="menu-text">Distribution API</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../concepts/03_tile_distribution.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tile Distribution - The Core API</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../concepts/03_tile_window.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tile Window - Data Access Gateway</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../concepts/03_sweep_tile.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Sweep Tile - Elegant Iteration</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true">
 <span class="menu-text">Coordinate Systems</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../concepts/04_coordinate_systems.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Coordinate Systems - The Mathematical Foundation</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true">
 <span class="menu-text">Implementation Deep Dive</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../concepts/05_encoding_internals.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Encoding Internals - The Internal Machinery</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../concepts/05_static_distributed_tensor.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Static Distributed Tensor - Thread-Local Data Containers</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="true">
 <span class="menu-text">Thread Mapping</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../concepts/06_thread_mapping.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Thread Mapping - Connecting to Hardware</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../concepts/02_tensor_coordinates.html">Transformation Engine</a></li><li class="breadcrumb-item"><a href="../concepts/02_convolution_example.html">Convolution Implementation with Tensor Descriptors</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Convolution Implementation with Tensor Descriptors</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>This chapter demonstrates a practical application of tensor descriptors by implementing convolution operations. We’ll progress from a naive implementation to an optimized approach using tensor descriptors, showing how they enable efficient memory access patterns for GPU acceleration. First we show how we can achieve the results using numpy implementation.</p>
<p>The convolution operation is fundamental in deep learning, and understanding its implementation details reveals how high-performance libraries achieve their efficiency. We’ll explore:</p>
<ol type="1">
<li><strong>Naive Implementation</strong>: Direct nested loops for reference</li>
<li><strong>Window Extraction</strong>: Using NumPy’s <code>as_strided</code> for overlapping windows</li>
<li><strong>Tensor Descriptor Windows</strong>: Achieving the same with tensor descriptors</li>
<li><strong>Im2col Transformation</strong>: Converting convolution to matrix multiplication</li>
<li><strong>Multi-channel Extension</strong>: Handling realistic deep learning scenarios</li>
</ol>
<section id="setup-and-test-data" class="level2">
<h2 class="anchored" data-anchor-id="setup-and-test-data">Setup and Test Data</h2>
<div id="99f2f788" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Import all required modules for the page</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>sys.path.insert(<span class="dv">0</span>, <span class="st">"../pytensor"</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pytensor.tensor_descriptor <span class="im">import</span> (</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    make_naive_tensor_descriptor,</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    make_naive_tensor_descriptor_packed,</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    make_naive_tensor_descriptor_aligned,</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    transform_tensor_descriptor,</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    PassThroughTransform,</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    UnmergeTransform,</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    MergeTransform, make_merge_transform</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cdeea29b" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pytensor.tensor_descriptor <span class="im">import</span> (</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    EmbedTransform, MergeTransform, MultiIndex,</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    make_naive_tensor_descriptor, transform_tensor_descriptor,</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    make_merge_transform</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_test_data():</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Create test data for convolution examples."""</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 6x6 input image with sequential numbers (easier to follow)</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    image <span class="op">=</span> np.arange(<span class="dv">1</span>, <span class="dv">37</span>).reshape(<span class="dv">6</span>, <span class="dv">6</span>)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Random 3x3 kernel for more interesting output</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    np.random.seed(<span class="dv">42</span>)  <span class="co"># For reproducible results</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    kernel <span class="op">=</span> np.random.randint(<span class="op">-</span><span class="dv">2</span>, <span class="dv">3</span>, (<span class="dv">3</span>, <span class="dv">3</span>))</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> image, kernel</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> print_matrix(matrix, title<span class="op">=</span><span class="st">"Matrix"</span>):</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Print a matrix in a nice format."""</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> title:</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="sc">{</span>title<span class="sc">}</span><span class="ss">:"</span>)</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(matrix.shape) <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> row <span class="kw">in</span> matrix:</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">" "</span>.join(<span class="ss">f"</span><span class="sc">{</span>val<span class="sc">:3.0f}</span><span class="ss">"</span> <span class="cf">if</span> <span class="bu">abs</span>(val <span class="op">-</span> <span class="bu">round</span>(val)) <span class="op">&lt;</span> <span class="fl">1e-10</span> <span class="cf">else</span> <span class="ss">f"</span><span class="sc">{</span>val<span class="sc">:3.1f}</span><span class="ss">"</span> </span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>                          <span class="cf">for</span> val <span class="kw">in</span> row))</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Shape: </span><span class="sc">{</span>matrix<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(matrix)</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> print_windows_tiled(windows, title<span class="op">=</span><span class="st">"Windows Tiled View"</span>):</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Print 4D windows tensor as a tiled 2D layout with spacing."""</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> title:</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="sc">{</span>title<span class="sc">}</span><span class="ss">:"</span>)</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    out_h, out_w, K, K <span class="op">=</span> windows.shape</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create separator patterns</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Each number takes 3 chars, separated by spaces, so K numbers = 3*K + (K-1) chars</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>    window_width <span class="op">=</span> <span class="dv">3</span> <span class="op">*</span> K <span class="op">+</span> (K <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>    row_sep <span class="op">=</span> <span class="st">"-"</span> <span class="op">*</span> window_width</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>    col_sep <span class="op">=</span> <span class="st">" | "</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> window_row <span class="kw">in</span> <span class="bu">range</span>(out_h):</span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Print each row of windows</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k_row <span class="kw">in</span> <span class="bu">range</span>(K):</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>            line_parts <span class="op">=</span> []</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> window_col <span class="kw">in</span> <span class="bu">range</span>(out_w):</span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>                window_data <span class="op">=</span> <span class="st">" "</span>.join(<span class="ss">f"</span><span class="sc">{</span>val<span class="sc">:3.0f}</span><span class="ss">"</span> <span class="cf">for</span> val <span class="kw">in</span> windows[window_row, window_col, k_row, :])</span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>                line_parts.append(window_data)</span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(col_sep.join(line_parts))</span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Print horizontal separator between window rows (except after last row)</span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> window_row <span class="op">&lt;</span> out_h <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Create separator that aligns with the | characters in content lines</span></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Content uses " | " so separator should use " + "</span></span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>            sep_parts <span class="op">=</span> [row_sep] <span class="op">*</span> out_w</span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>            sep_line <span class="op">=</span> (<span class="st">" + "</span>).join(sep_parts)</span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(sep_line)</span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>()  <span class="co"># Empty line for spacing</span></span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a><span class="co"># Create our test data</span></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>image, kernel <span class="op">=</span> create_test_data()</span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>print_matrix(image, <span class="st">"6×6 Input Image"</span>)</span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>print_matrix(kernel, <span class="st">"3×3 Kernel (Edge Detection)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
6×6 Input Image:
  1   2   3   4   5   6
  7   8   9  10  11  12
 13  14  15  16  17  18
 19  20  21  22  23  24
 25  26  27  28  29  30
 31  32  33  34  35  36

3×3 Kernel (Edge Detection):
  1   2   0
  2   2  -1
  0   0   0</code></pre>
</div>
</div>
</section>
<section id="understanding-as_strided-simple-tiling-first" class="level2">
<h2 class="anchored" data-anchor-id="understanding-as_strided-simple-tiling-first">Understanding as_strided: Simple Tiling First</h2>
<p>Before diving into convolution, let’s understand how <code>as_strided</code> works with a simple example. We’ll start by tiling our matrix into non-overlapping blocks.</p>
<div id="addd7545" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> demonstrate_simple_tiling():</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Demonstrate simple tiling with as_strided (no overlap)."""</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> numpy.lib.stride_tricks <span class="im">import</span> as_strided</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a simple 6x6 matrix</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    matrix <span class="op">=</span> np.arange(<span class="dv">1</span>, <span class="dv">37</span>).reshape(<span class="dv">6</span>, <span class="dv">6</span>)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    print_matrix(matrix, <span class="st">"Original 6×6 Matrix"</span>)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Tile into 2x2 blocks (no overlap)</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    tile_size <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    matrix_h, matrix_w <span class="op">=</span> matrix.shape</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    num_tiles_h <span class="op">=</span> matrix_h <span class="op">//</span> tile_size</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    num_tiles_w <span class="op">=</span> matrix_w <span class="op">//</span> tile_size</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Tiling into </span><span class="sc">{</span>num_tiles_h<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>num_tiles_w<span class="sc">}</span><span class="ss"> tiles of size </span><span class="sc">{</span>tile_size<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>tile_size<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Original strides: </span><span class="sc">{</span>matrix<span class="sc">.</span>strides<span class="sc">}</span><span class="ss"> (bytes per step)"</span>)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate new strides for tiling</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># To move to next tile vertically: jump tile_size rows</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># To move to next tile horizontally: jump tile_size columns  </span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Within tile: use original strides</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    tiles <span class="op">=</span> as_strided(</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>        matrix,</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        shape<span class="op">=</span>(num_tiles_h, num_tiles_w, tile_size, tile_size),</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>        strides<span class="op">=</span>(matrix.strides[<span class="dv">0</span>] <span class="op">*</span> tile_size, matrix.strides[<span class="dv">1</span>] <span class="op">*</span> tile_size, </span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>                matrix.strides[<span class="dv">0</span>], matrix.strides[<span class="dv">1</span>])</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Tiles shape: </span><span class="sc">{</span>tiles<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"New strides: </span><span class="sc">{</span>tiles<span class="sc">.</span>strides<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Stride calculation:"</span>)</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  - Move to next tile row: </span><span class="sc">{</span>matrix<span class="sc">.</span>strides[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> × </span><span class="sc">{</span>tile_size<span class="sc">}</span><span class="ss"> = </span><span class="sc">{</span>matrix<span class="sc">.</span>strides[<span class="dv">0</span>] <span class="op">*</span> tile_size<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  - Move to next tile col: </span><span class="sc">{</span>matrix<span class="sc">.</span>strides[<span class="dv">1</span>]<span class="sc">}</span><span class="ss"> × </span><span class="sc">{</span>tile_size<span class="sc">}</span><span class="ss"> = </span><span class="sc">{</span>matrix<span class="sc">.</span>strides[<span class="dv">1</span>] <span class="op">*</span> tile_size<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  - Within tile row: </span><span class="sc">{</span>matrix<span class="sc">.</span>strides[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> (original)"</span>)</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  - Within tile col: </span><span class="sc">{</span>matrix<span class="sc">.</span>strides[<span class="dv">1</span>]<span class="sc">}</span><span class="ss"> (original)"</span>)</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tiles</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Demonstrate simple tiling</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>tiles <span class="op">=</span> demonstrate_simple_tiling()</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Show all tiles in tiled layout</span></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>print_windows_tiled(tiles, <span class="st">"All 2×2 Tiles in Tiled Layout"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Original 6×6 Matrix:
  1   2   3   4   5   6
  7   8   9  10  11  12
 13  14  15  16  17  18
 19  20  21  22  23  24
 25  26  27  28  29  30
 31  32  33  34  35  36

Tiling into 3×3 tiles of size 2×2
Original strides: (48, 8) (bytes per step)
Tiles shape: (3, 3, 2, 2)
New strides: (96, 16, 48, 8)
Stride calculation:
  - Move to next tile row: 48 × 2 = 96
  - Move to next tile col: 8 × 2 = 16
  - Within tile row: 48 (original)
  - Within tile col: 8 (original)

All 2×2 Tiles in Tiled Layout:
  1   2 |   3   4 |   5   6
  7   8 |   9  10 |  11  12
------- + ------- + -------
 13  14 |  15  16 |  17  18
 19  20 |  21  22 |  23  24
------- + ------- + -------
 25  26 |  27  28 |  29  30
 31  32 |  33  34 |  35  36
</code></pre>
</div>
</div>
<section id="understanding-strides" class="level3">
<h3 class="anchored" data-anchor-id="understanding-strides">Understanding Strides</h3>
<p>The key insight is understanding <strong>strides</strong> - how many bytes to skip to move to the next element in each dimension:</p>
<ul>
<li><strong>Original matrix</strong>: <code>shape=(6, 6)</code>, <code>strides=(48, 8)</code> (8 bytes per int64, 6 elements per row)</li>
<li><strong>Tiled view</strong>: <code>shape=(3, 3, 2, 2)</code>, <code>strides=(96, 16, 48, 8)</code>
<ul>
<li>To move to next tile row: skip 2 matrix rows = <code>48 × 2 = 96</code> bytes</li>
<li>To move to next tile col: skip 2 matrix cols = <code>8 × 2 = 16</code> bytes<br>
</li>
<li>Within tile: use original strides <code>(48, 8)</code></li>
</ul></li>
</ul>
</section>
</section>
<section id="overlapping-windows-with-as_strided" class="level2">
<h2 class="anchored" data-anchor-id="overlapping-windows-with-as_strided">Overlapping Windows with as_strided</h2>
<p>Now let’s see how to create overlapping windows - the foundation of convolution:</p>
<div id="b36a5140" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> demonstrate_overlapping_windows():</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Demonstrate overlapping windows with as_strided."""</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> numpy.lib.stride_tricks <span class="im">import</span> as_strided</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Use our test image</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    image, _ <span class="op">=</span> create_test_data()</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    print_matrix(image, <span class="st">"6×6 Input Image"</span>)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract 3x3 overlapping windows</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    K <span class="op">=</span> <span class="dv">3</span>  <span class="co"># kernel size</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    H, W <span class="op">=</span> image.shape</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    out_h, out_w <span class="op">=</span> H <span class="op">-</span> K <span class="op">+</span> <span class="dv">1</span>, W <span class="op">-</span> K <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Extracting </span><span class="sc">{</span>K<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>K<span class="sc">}</span><span class="ss"> overlapping windows"</span>)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Output positions: </span><span class="sc">{</span>out_h<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>out_w<span class="sc">}</span><span class="ss"> = </span><span class="sc">{</span>out_h <span class="op">*</span> out_w<span class="sc">}</span><span class="ss"> windows"</span>)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Original strides: </span><span class="sc">{</span>image<span class="sc">.</span>strides<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># For overlapping windows, we move by 1 element (not tile_size)</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># But within each window, we still use original strides</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    windows <span class="op">=</span> as_strided(</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        image,</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>        shape<span class="op">=</span>(out_h, out_w, K, K),</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        strides<span class="op">=</span>(image.strides[<span class="dv">0</span>], image.strides[<span class="dv">1</span>], image.strides[<span class="dv">0</span>], image.strides[<span class="dv">1</span>])</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Windows shape: </span><span class="sc">{</span>windows<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"New strides: </span><span class="sc">{</span>windows<span class="sc">.</span>strides<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Stride meaning:"</span>)</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  - Move to next window row: </span><span class="sc">{</span>image<span class="sc">.</span>strides[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> (1 row down)"</span>)</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  - Move to next window col: </span><span class="sc">{</span>image<span class="sc">.</span>strides[<span class="dv">1</span>]<span class="sc">}</span><span class="ss"> (1 col right)"</span>)</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  - Within window row: </span><span class="sc">{</span>image<span class="sc">.</span>strides[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> (1 row down)"</span>)</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  - Within window col: </span><span class="sc">{</span>image<span class="sc">.</span>strides[<span class="dv">1</span>]<span class="sc">}</span><span class="ss"> (1 col right)"</span>)</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> windows</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a><span class="co"># Demonstrate overlapping windows</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>windows <span class="op">=</span> demonstrate_overlapping_windows()</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Show all overlapping windows in tiled layout</span></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>print_windows_tiled(windows, <span class="st">"All 3×3 Overlapping Windows in Tiled Layout"</span>)</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Notice the overlap - adjacent windows share columns and rows!"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
6×6 Input Image:
  1   2   3   4   5   6
  7   8   9  10  11  12
 13  14  15  16  17  18
 19  20  21  22  23  24
 25  26  27  28  29  30
 31  32  33  34  35  36

Extracting 3×3 overlapping windows
Output positions: 4×4 = 16 windows
Original strides: (48, 8)
Windows shape: (4, 4, 3, 3)
New strides: (48, 8, 48, 8)
Stride meaning:
  - Move to next window row: 48 (1 row down)
  - Move to next window col: 8 (1 col right)
  - Within window row: 48 (1 row down)
  - Within window col: 8 (1 col right)

All 3×3 Overlapping Windows in Tiled Layout:
  1   2   3 |   2   3   4 |   3   4   5 |   4   5   6
  7   8   9 |   8   9  10 |   9  10  11 |  10  11  12
 13  14  15 |  14  15  16 |  15  16  17 |  16  17  18
----------- + ----------- + ----------- + -----------
  7   8   9 |   8   9  10 |   9  10  11 |  10  11  12
 13  14  15 |  14  15  16 |  15  16  17 |  16  17  18
 19  20  21 |  20  21  22 |  21  22  23 |  22  23  24
----------- + ----------- + ----------- + -----------
 13  14  15 |  14  15  16 |  15  16  17 |  16  17  18
 19  20  21 |  20  21  22 |  21  22  23 |  22  23  24
 25  26  27 |  26  27  28 |  27  28  29 |  28  29  30
----------- + ----------- + ----------- + -----------
 19  20  21 |  20  21  22 |  21  22  23 |  22  23  24
 25  26  27 |  26  27  28 |  27  28  29 |  28  29  30
 31  32  33 |  32  33  34 |  33  34  35 |  34  35  36


Notice the overlap - adjacent windows share columns and rows!</code></pre>
</div>
</div>
<section id="key-difference-overlap-vs-no-overlap" class="level3">
<h3 class="anchored" data-anchor-id="key-difference-overlap-vs-no-overlap">Key Difference: Overlap vs No Overlap</h3>
<ul>
<li><strong>Non-overlapping tiles</strong>: We skip by <code>tile_size</code> in strides: <code>(stride[0] * tile_size, stride[1] * tile_size, ...)</code></li>
<li><strong>Overlapping windows</strong>: We skip by <code>1</code> in strides: <code>(stride[0] * 1, stride[1] * 1, ...)</code></li>
</ul>
<p>This creates sliding windows that overlap, which is exactly what we need for convolution!</p>
</section>
</section>
<section id="naive-convolution-reference" class="level2">
<h2 class="anchored" data-anchor-id="naive-convolution-reference">1. Naive Convolution Reference</h2>
<p>Let’s start with the most straightforward implementation using nested loops:</p>
<div id="a22a86cd" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> naive_convolution_2d(image, kernel):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Reference implementation: naive 2D convolution with nested loops."""</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    H, W <span class="op">=</span> image.shape</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    K <span class="op">=</span> kernel.shape[<span class="dv">0</span>]  <span class="co"># Assume square kernel</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    out_h, out_w <span class="op">=</span> H <span class="op">-</span> K <span class="op">+</span> <span class="dv">1</span>, W <span class="op">-</span> K <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> np.zeros((out_h, out_w))</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Input shape: </span><span class="sc">{</span>image<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Kernel shape: </span><span class="sc">{</span>kernel<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Output shape: </span><span class="sc">{</span>output<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(out_h):</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(out_w):</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Extract window</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>            window <span class="op">=</span> image[i:i<span class="op">+</span>K, j:j<span class="op">+</span>K]</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Apply convolution</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>            output[i, j] <span class="op">=</span> np.<span class="bu">sum</span>(window <span class="op">*</span> kernel)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> output</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Run naive convolution</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>reference_output <span class="op">=</span> naive_convolution_2d(image, kernel)</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>print_matrix(reference_output, <span class="st">"Naive Convolution Output"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Input shape: (6, 6)
Kernel shape: (3, 3)
Output shape: (4, 4)

Naive Convolution Output:
 26  32  38  44
 62  68  74  80
 98 104 110 116
134 140 146 152</code></pre>
</div>
</div>
<p>This implementation directly follows the mathematical definition of convolution. For each output position, we extract the corresponding window from the input image and compute the element-wise product with the kernel.</p>
</section>
<section id="window-extraction-with-numpy-as_strided" class="level2">
<h2 class="anchored" data-anchor-id="window-extraction-with-numpy-as_strided">2. Window Extraction with NumPy as_strided</h2>
<p>Now let’s apply what we learned about overlapping windows to convolution. We need to extract all 3×3 windows for convolution:</p>
<div id="932697e9" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> extract_windows_numpy(image, kernel_size<span class="op">=</span><span class="dv">3</span>):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Extract convolution windows using numpy as_strided."""</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> numpy.lib.stride_tricks <span class="im">import</span> as_strided</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    H, W <span class="op">=</span> image.shape</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    K <span class="op">=</span> kernel_size</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    out_h, out_w <span class="op">=</span> H <span class="op">-</span> K <span class="op">+</span> <span class="dv">1</span>, W <span class="op">-</span> K <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Use as_strided to create overlapping windows</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    windows <span class="op">=</span> as_strided(</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        image,</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        shape<span class="op">=</span>(out_h, out_w, K, K),</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        strides<span class="op">=</span>(image.strides[<span class="dv">0</span>], image.strides[<span class="dv">1</span>], image.strides[<span class="dv">0</span>], image.strides[<span class="dv">1</span>])</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Original image shape: </span><span class="sc">{</span>image<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Windows shape: </span><span class="sc">{</span>windows<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Memory view: 4D tensor [out_h, out_w, kernel_h, kernel_w]"</span>)</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> windows</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract windows</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>windows_numpy <span class="op">=</span> extract_windows_numpy(image)</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Show windows in tiled layout</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>print_windows_tiled(windows_numpy, <span class="st">"All Windows in Tiled Layout"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Original image shape: (6, 6)
Windows shape: (4, 4, 3, 3)
Memory view: 4D tensor [out_h, out_w, kernel_h, kernel_w]

All Windows in Tiled Layout:
  1   2   3 |   2   3   4 |   3   4   5 |   4   5   6
  7   8   9 |   8   9  10 |   9  10  11 |  10  11  12
 13  14  15 |  14  15  16 |  15  16  17 |  16  17  18
----------- + ----------- + ----------- + -----------
  7   8   9 |   8   9  10 |   9  10  11 |  10  11  12
 13  14  15 |  14  15  16 |  15  16  17 |  16  17  18
 19  20  21 |  20  21  22 |  21  22  23 |  22  23  24
----------- + ----------- + ----------- + -----------
 13  14  15 |  14  15  16 |  15  16  17 |  16  17  18
 19  20  21 |  20  21  22 |  21  22  23 |  22  23  24
 25  26  27 |  26  27  28 |  27  28  29 |  28  29  30
----------- + ----------- + ----------- + -----------
 19  20  21 |  20  21  22 |  21  22  23 |  22  23  24
 25  26  27 |  26  27  28 |  27  28  29 |  28  29  30
 31  32  33 |  32  33  34 |  33  34  35 |  34  35  36
</code></pre>
</div>
</div>
<p>Perfect! We now have a 4D tensor <code>[4, 4, 3, 3]</code> containing all 16 convolution windows. Each <code>[i, j, :, :]</code> slice contains the window at output position <code>(i, j)</code>.</p>
</section>
<section id="window-extraction-with-tensor-descriptors" class="level2">
<h2 class="anchored" data-anchor-id="window-extraction-with-tensor-descriptors">3. Window Extraction with Tensor Descriptors</h2>
<p>Now let’s achieve the same result using tensor descriptors, we have seen a similar results before when we learnt about the <code>EmbedTransform</code> that is behind <code>make_naive_tensor_descriptor</code>.</p>
<div id="2ca47e35" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> extract_windows_tensor_descriptor(image, kernel_size<span class="op">=</span><span class="dv">3</span>):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Extract convolution windows using Tensor Descriptors."""</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    H, W <span class="op">=</span> image.shape</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    K <span class="op">=</span> kernel_size</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    out_h, out_w <span class="op">=</span> H <span class="op">-</span> K <span class="op">+</span> <span class="dv">1</span>, W <span class="op">-</span> K <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create tensor descriptor for 4D windows</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    window_lengths <span class="op">=</span> [out_h, out_w, K, K]</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    window_strides <span class="op">=</span> [W, <span class="dv">1</span>, W, <span class="dv">1</span>]  <span class="co"># Strides for overlapping windows</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    windows_descriptor <span class="op">=</span> make_naive_tensor_descriptor(window_lengths, window_strides)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Tensor descriptor shape: </span><span class="sc">{</span>windows_descriptor<span class="sc">.</span>get_lengths()<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Element space size: </span><span class="sc">{</span>windows_descriptor<span class="sc">.</span>get_element_space_size()<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract windows using tensor descriptor</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    image_flat <span class="op">=</span> image.flatten()</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>    windows_td <span class="op">=</span> np.zeros((out_h, out_w, K, K))</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(out_h):</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(out_w):</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> ki <span class="kw">in</span> <span class="bu">range</span>(K):</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> kj <span class="kw">in</span> <span class="bu">range</span>(K):</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>                    offset <span class="op">=</span> windows_descriptor.calculate_offset([i, j, ki, kj])</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>                    windows_td[i, j, ki, kj] <span class="op">=</span> image_flat[offset]</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> windows_td</span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract windows using tensor descriptor</span></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>windows_td <span class="op">=</span> extract_windows_tensor_descriptor(image)</span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Show all windows in tiled layout</span></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>print_windows_tiled(windows_td, <span class="st">"All Windows in Tiled Layout (Tensor Descriptor)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Tensor descriptor shape: [4, 4, 3, 3]
Element space size: 36

All Windows in Tiled Layout (Tensor Descriptor):
  1   2   3 |   2   3   4 |   3   4   5 |   4   5   6
  7   8   9 |   8   9  10 |   9  10  11 |  10  11  12
 13  14  15 |  14  15  16 |  15  16  17 |  16  17  18
----------- + ----------- + ----------- + -----------
  7   8   9 |   8   9  10 |   9  10  11 |  10  11  12
 13  14  15 |  14  15  16 |  15  16  17 |  16  17  18
 19  20  21 |  20  21  22 |  21  22  23 |  22  23  24
----------- + ----------- + ----------- + -----------
 13  14  15 |  14  15  16 |  15  16  17 |  16  17  18
 19  20  21 |  20  21  22 |  21  22  23 |  22  23  24
 25  26  27 |  26  27  28 |  27  28  29 |  28  29  30
----------- + ----------- + ----------- + -----------
 19  20  21 |  20  21  22 |  21  22  23 |  22  23  24
 25  26  27 |  26  27  28 |  27  28  29 |  28  29  30
 31  32  33 |  32  33  34 |  33  34  35 |  34  35  36
</code></pre>
</div>
</div>
<p>The key insight is the stride pattern <code>[W, 1, W, 1]</code>:</p>
<ul>
<li>Moving one step in <code>out_h</code> direction requires jumping <code>W</code> elements (one row)</li>
<li>Moving one step in <code>out_w</code> direction requires jumping <code>1</code> element (one column)<br>
</li>
<li>Moving one step in <code>kernel_h</code> direction requires jumping <code>W</code> elements (one row)</li>
<li>Moving one step in <code>kernel_w</code> direction requires jumping <code>1</code> element (one column)</li>
</ul>
<section id="verification-numpy-vs-tensor-descriptor-windows" class="level3">
<h3 class="anchored" data-anchor-id="verification-numpy-vs-tensor-descriptor-windows">Verification: NumPy vs Tensor Descriptor Windows</h3>
<p>We can see that we get the same results as we do in numpy approach.</p>
<div id="e6a1cf58" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compare the two approaches</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>difference <span class="op">=</span> np.linalg.norm(windows_numpy <span class="op">-</span> windows_td)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"L2 norm of difference: </span><span class="sc">{</span>difference<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> difference <span class="op">&lt;</span> <span class="fl">1e-10</span>:</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"✅ SUCCESS: Tensor descriptor windows identical to NumPy!"</span>)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"❌ ERROR: Tensor descriptor windows differ from NumPy"</span>)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Max difference: </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">max</span>(np.<span class="bu">abs</span>(windows_numpy <span class="op">-</span> windows_td))<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>L2 norm of difference: 0.0
✅ SUCCESS: Tensor descriptor windows identical to NumPy!</code></pre>
</div>
</div>
</section>
</section>
<section id="im2col-transformation-with-numpy" class="level2">
<h2 class="anchored" data-anchor-id="im2col-transformation-with-numpy">4. Im2col Transformation with NumPy</h2>
<p>The next step is converting our 4D windows to a 2D matrix format suitable for matrix multiplication. This is called the “im2col” (image to column) transformation. This can be done by using reshape operator of numpy.</p>
<div id="671bf27e" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> im2col_numpy(windows):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Convert 4D windows to 2D im2col matrix using NumPy."""</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    out_h, out_w, K, K <span class="op">=</span> windows.shape</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    num_windows <span class="op">=</span> out_h <span class="op">*</span> out_w</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    patch_size <span class="op">=</span> K <span class="op">*</span> K</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reshape to 2D matrix</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    im2col_matrix <span class="op">=</span> windows.reshape(num_windows, patch_size)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"4D windows shape: </span><span class="sc">{</span>windows<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"2D im2col shape: </span><span class="sc">{</span>im2col_matrix<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Transformation: [</span><span class="sc">{</span>out_h<span class="sc">}</span><span class="ss">, </span><span class="sc">{</span>out_w<span class="sc">}</span><span class="ss">, </span><span class="sc">{</span>K<span class="sc">}</span><span class="ss">, </span><span class="sc">{</span>K<span class="sc">}</span><span class="ss">] → [</span><span class="sc">{</span>num_windows<span class="sc">}</span><span class="ss">, </span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">]"</span>)</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> im2col_matrix</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Create im2col matrix</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>im2col_numpy <span class="op">=</span> im2col_numpy(windows_numpy)</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Show the matrix structure</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Im2col matrix (each row is a flattened window):"</span>)</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>out_h, out_w <span class="op">=</span> <span class="dv">4</span>, <span class="dv">4</span>  <span class="co"># Our output dimensions</span></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, row <span class="kw">in</span> <span class="bu">enumerate</span>(im2col_numpy):</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>    win_i, win_j <span class="op">=</span> i <span class="op">//</span> out_w, i <span class="op">%</span> out_w</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Row </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss"> (window [</span><span class="sc">{</span>win_i<span class="sc">}</span><span class="ss">,</span><span class="sc">{</span>win_j<span class="sc">}</span><span class="ss">]): </span><span class="sc">{</span><span class="st">' '</span><span class="sc">.</span>join(<span class="ss">f'</span><span class="sc">{</span>val<span class="sc">:3.0f}</span><span class="ss">'</span> <span class="cf">for</span> val <span class="kw">in</span> row)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>4D windows shape: (4, 4, 3, 3)
2D im2col shape: (16, 9)
Transformation: [4, 4, 3, 3] → [16, 9]

Im2col matrix (each row is a flattened window):
Row 0 (window [0,0]):   1   2   3   7   8   9  13  14  15
Row 1 (window [0,1]):   2   3   4   8   9  10  14  15  16
Row 2 (window [0,2]):   3   4   5   9  10  11  15  16  17
Row 3 (window [0,3]):   4   5   6  10  11  12  16  17  18
Row 4 (window [1,0]):   7   8   9  13  14  15  19  20  21
Row 5 (window [1,1]):   8   9  10  14  15  16  20  21  22
Row 6 (window [1,2]):   9  10  11  15  16  17  21  22  23
Row 7 (window [1,3]):  10  11  12  16  17  18  22  23  24
Row 8 (window [2,0]):  13  14  15  19  20  21  25  26  27
Row 9 (window [2,1]):  14  15  16  20  21  22  26  27  28
Row 10 (window [2,2]):  15  16  17  21  22  23  27  28  29
Row 11 (window [2,3]):  16  17  18  22  23  24  28  29  30
Row 12 (window [3,0]):  19  20  21  25  26  27  31  32  33
Row 13 (window [3,1]):  20  21  22  26  27  28  32  33  34
Row 14 (window [3,2]):  21  22  23  27  28  29  33  34  35
Row 15 (window [3,3]):  22  23  24  28  29  30  34  35  36</code></pre>
</div>
</div>
<p>Each row of the im2col matrix contains a flattened convolution window. This transformation allows us to compute all convolutions simultaneously using a single matrix multiplication.</p>
</section>
<section id="im2col-with-tensor-descriptors" class="level2">
<h2 class="anchored" data-anchor-id="im2col-with-tensor-descriptors">5. Im2col with Tensor Descriptors</h2>
<p>Since we already extracted windows using tensor descriptors, we can simply reshape them just like the NumPy version, let’s see how we can do it using the transformation pipelines.</p>
<section id="simple-approach-reshape-existing-windows" class="level3">
<h3 class="anchored" data-anchor-id="simple-approach-reshape-existing-windows">Simple Approach: Reshape Existing Windows</h3>
<p>Since we already extracted the 4D windows using a tensor descriptor, the simplest way to get the im2col matrix is to just reshape the result, similar to how we handled the NumPy array.</p>
<div id="85adea8f" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> im2col_td_simple(windows_td):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Convert 4D tensor descriptor windows to 2D im2col matrix."""</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    out_h, out_w, K, K <span class="op">=</span> windows_td.shape</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    num_windows <span class="op">=</span> out_h <span class="op">*</span> out_w</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    patch_size <span class="op">=</span> K <span class="op">*</span> K</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reshape to 2D matrix</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    im2col_matrix <span class="op">=</span> windows_td.reshape(num_windows, patch_size)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"4D TD windows shape: </span><span class="sc">{</span>windows_td<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"2D im2col (simple) shape: </span><span class="sc">{</span>im2col_matrix<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> im2col_matrix</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Create im2col from tensor descriptor windows</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>im2col_td_matrix <span class="op">=</span> im2col_td_simple(windows_td)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>4D TD windows shape: (4, 4, 3, 3)
2D im2col (simple) shape: (16, 9)</code></pre>
</div>
</div>
<p>Perfect! This is exactly the same as the NumPy approach - just reshape the 4D windows into a 2D matrix.</p>
</section>
<section id="advanced-direct-2d-tensor-descriptor" class="level3">
<h3 class="anchored" data-anchor-id="advanced-direct-2d-tensor-descriptor">Advanced: Direct 2D Tensor Descriptor</h3>
<p>However, tensor descriptors can also create the im2col layout directly without intermediate 4D windows. This is useful for GPU implementations:</p>
<div id="d2eb1e94" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pytensor.tensor_descriptor <span class="im">import</span> make_merge_transform</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_direct_im2col_descriptor(image, kernel_size<span class="op">=</span><span class="dv">3</span>):</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Create im2col matrix directly using tensor descriptors."""</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    H, W <span class="op">=</span> image.shape</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    K <span class="op">=</span> kernel_size</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    out_h, out_w <span class="op">=</span> H <span class="op">-</span> K <span class="op">+</span> <span class="dv">1</span>, W <span class="op">-</span> K <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Create 4D windows descriptor</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    window_lengths <span class="op">=</span> [out_h, out_w, K, K]</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    window_strides <span class="op">=</span> [W, <span class="dv">1</span>, W, <span class="dv">1</span>]</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    windows_descriptor <span class="op">=</span> make_naive_tensor_descriptor(window_lengths, window_strides)</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: Apply merge transforms to create 2D im2col layout directly</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    merge_windows <span class="op">=</span> make_merge_transform([out_h, out_w])  <span class="co"># Merge spatial output dimensions</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>    merge_patch <span class="op">=</span> make_merge_transform([K, K])  <span class="co"># Merge kernel dimensions</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>    im2col_descriptor <span class="op">=</span> transform_tensor_descriptor( <span class="co">#</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>        windows_descriptor,</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>        transforms<span class="op">=</span>[merge_windows, merge_patch],</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>        lower_dimension_hidden_idss<span class="op">=</span>[[<span class="dv">0</span>, <span class="dv">1</span>], [<span class="dv">2</span>, <span class="dv">3</span>]],</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>        upper_dimension_hidden_idss<span class="op">=</span>[[<span class="dv">0</span>], [<span class="dv">1</span>]]</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Direct im2col descriptor shape: </span><span class="sc">{</span>im2col_descriptor<span class="sc">.</span>get_lengths()<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> im2col_descriptor</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Create direct im2col descriptor</span></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>im2col_descriptor <span class="op">=</span> create_direct_im2col_descriptor(image)</span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a><span class="co"># This descriptor can directly compute offsets for the 2D im2col layout</span></span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Example: offset for window 0, patch element 0: </span><span class="sc">{</span>im2col_descriptor<span class="sc">.</span>calculate_offset([<span class="dv">0</span>, <span class="dv">0</span>])<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Example: offset for window 0, patch element 4: </span><span class="sc">{</span>im2col_descriptor<span class="sc">.</span>calculate_offset([<span class="dv">0</span>, <span class="dv">4</span>])<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Example: offset for window 1, patch element 0: </span><span class="sc">{</span>im2col_descriptor<span class="sc">.</span>calculate_offset([<span class="dv">1</span>, <span class="dv">0</span>])<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract data using the direct descriptor</span></span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> extract_im2col_with_descriptor(image, descriptor):</span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Extract im2col matrix using tensor descriptor."""</span></span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true" tabindex="-1"></a>    image_flat <span class="op">=</span> image.flatten()</span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true" tabindex="-1"></a>    descriptor_shape <span class="op">=</span> descriptor.get_lengths()</span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true" tabindex="-1"></a>    num_windows, patch_size <span class="op">=</span> descriptor_shape</span>
<span id="cb20-42"><a href="#cb20-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-43"><a href="#cb20-43" aria-hidden="true" tabindex="-1"></a>    im2col_matrix <span class="op">=</span> np.zeros((num_windows, patch_size))</span>
<span id="cb20-44"><a href="#cb20-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-45"><a href="#cb20-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_windows):</span>
<span id="cb20-46"><a href="#cb20-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(patch_size):</span>
<span id="cb20-47"><a href="#cb20-47" aria-hidden="true" tabindex="-1"></a>            offset <span class="op">=</span> descriptor.calculate_offset([i, j])</span>
<span id="cb20-48"><a href="#cb20-48" aria-hidden="true" tabindex="-1"></a>            im2col_matrix[i, j] <span class="op">=</span> image_flat[offset]</span>
<span id="cb20-49"><a href="#cb20-49" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-50"><a href="#cb20-50" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Extracted im2col matrix using descriptor: </span><span class="sc">{</span>im2col_matrix<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb20-51"><a href="#cb20-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> im2col_matrix</span>
<span id="cb20-52"><a href="#cb20-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-53"><a href="#cb20-53" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract im2col matrix using tensor descriptor</span></span>
<span id="cb20-54"><a href="#cb20-54" aria-hidden="true" tabindex="-1"></a>im2col_td_direct <span class="op">=</span> extract_im2col_with_descriptor(image, im2col_descriptor)</span>
<span id="cb20-55"><a href="#cb20-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-56"><a href="#cb20-56" aria-hidden="true" tabindex="-1"></a><span class="co"># Show the matrix structure</span></span>
<span id="cb20-57"><a href="#cb20-57" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">im2col_td_direct matrix (each row is a flattened window):"</span>)</span>
<span id="cb20-58"><a href="#cb20-58" aria-hidden="true" tabindex="-1"></a>out_h, out_w <span class="op">=</span> <span class="dv">4</span>, <span class="dv">4</span>  <span class="co"># Our output dimensions</span></span>
<span id="cb20-59"><a href="#cb20-59" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, row <span class="kw">in</span> <span class="bu">enumerate</span>(im2col_td_direct):</span>
<span id="cb20-60"><a href="#cb20-60" aria-hidden="true" tabindex="-1"></a>    win_i, win_j <span class="op">=</span> i <span class="op">//</span> out_w, i <span class="op">%</span> out_w</span>
<span id="cb20-61"><a href="#cb20-61" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Row </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss"> (window [</span><span class="sc">{</span>win_i<span class="sc">}</span><span class="ss">,</span><span class="sc">{</span>win_j<span class="sc">}</span><span class="ss">]): </span><span class="sc">{</span><span class="st">' '</span><span class="sc">.</span>join(<span class="ss">f'</span><span class="sc">{</span>val<span class="sc">:3.0f}</span><span class="ss">'</span> <span class="cf">for</span> val <span class="kw">in</span> row)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Direct im2col descriptor shape: [16, 9]

Example: offset for window 0, patch element 0: 0
Example: offset for window 0, patch element 4: 7
Example: offset for window 1, patch element 0: 1
Extracted im2col matrix using descriptor: (16, 9)

im2col_td_direct matrix (each row is a flattened window):
Row 0 (window [0,0]):   1   2   3   7   8   9  13  14  15
Row 1 (window [0,1]):   2   3   4   8   9  10  14  15  16
Row 2 (window [0,2]):   3   4   5   9  10  11  15  16  17
Row 3 (window [0,3]):   4   5   6  10  11  12  16  17  18
Row 4 (window [1,0]):   7   8   9  13  14  15  19  20  21
Row 5 (window [1,1]):   8   9  10  14  15  16  20  21  22
Row 6 (window [1,2]):   9  10  11  15  16  17  21  22  23
Row 7 (window [1,3]):  10  11  12  16  17  18  22  23  24
Row 8 (window [2,0]):  13  14  15  19  20  21  25  26  27
Row 9 (window [2,1]):  14  15  16  20  21  22  26  27  28
Row 10 (window [2,2]):  15  16  17  21  22  23  27  28  29
Row 11 (window [2,3]):  16  17  18  22  23  24  28  29  30
Row 12 (window [3,0]):  19  20  21  25  26  27  31  32  33
Row 13 (window [3,1]):  20  21  22  26  27  28  32  33  34
Row 14 (window [3,2]):  21  22  23  27  28  29  33  34  35
Row 15 (window [3,3]):  22  23  24  28  29  30  34  35  36</code></pre>
</div>
</div>
</section>
<section id="why-both-approaches" class="level3">
<h3 class="anchored" data-anchor-id="why-both-approaches">Why Both Approaches?</h3>
<ul>
<li><strong>Simple reshape</strong>: Easy to understand, perfect for CPU implementations</li>
<li><strong>Direct tensor descriptor</strong>: Enables efficient GPU kernel generation where the hardware can directly compute memory addresses for the im2col layout without materializing intermediate 4D arrays</li>
</ul>
<p>The advanced direct tensor descriptor approach uses two <code>MergeTransform</code> operations: 1. <strong>Merge spatial dimensions</strong>: <code>[out_h, out_w] → num_windows</code> 2. <strong>Merge kernel dimensions</strong>: <code>[K, K] → patch_size</code></p>
<p>This transforms the 4D tensor <code>[out_h, out_w, K, K]</code> directly into a 2D matrix <code>[num_windows, patch_size]</code> without materializing the intermediate 4D array.</p>
</section>
<section id="verification-numpy-vs-tensor-descriptor-im2col" class="level3">
<h3 class="anchored" data-anchor-id="verification-numpy-vs-tensor-descriptor-im2col">Verification: NumPy vs Tensor Descriptor Im2col</h3>
<div id="b1393caf" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compare NumPy approach with direct tensor descriptor approach</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>difference <span class="op">=</span> np.linalg.norm(im2col_numpy <span class="op">-</span> im2col_td_direct)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"L2 norm of difference (NumPy vs Tensor Descriptor): </span><span class="sc">{</span>difference<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> difference <span class="op">&lt;</span> <span class="fl">1e-10</span>:</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"✅ SUCCESS: Tensor descriptor im2col identical to NumPy!"</span>)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"❌ ERROR: Tensor descriptor im2col differs from NumPy"</span>)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Max difference: </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">max</span>(np.<span class="bu">abs</span>(im2col_numpy <span class="op">-</span> im2col_td_direct))<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Also verify that simple reshape gives same result</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>difference_simple <span class="op">=</span> np.linalg.norm(im2col_numpy <span class="op">-</span> im2col_td_matrix)</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">L2 norm of difference (NumPy vs Simple Reshape): </span><span class="sc">{</span>difference_simple<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> difference_simple <span class="op">&lt;</span> <span class="fl">1e-10</span>:</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"✅ SUCCESS: Simple reshape approach also identical!"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>L2 norm of difference (NumPy vs Tensor Descriptor): 0.0
✅ SUCCESS: Tensor descriptor im2col identical to NumPy!

L2 norm of difference (NumPy vs Simple Reshape): 0.0
✅ SUCCESS: Simple reshape approach also identical!</code></pre>
</div>
</div>
</section>
</section>
<section id="convolution-via-matrix-multiplication" class="level2">
<h2 class="anchored" data-anchor-id="convolution-via-matrix-multiplication">6. Convolution via Matrix Multiplication</h2>
<p>With our im2col matrix ready, we can now perform convolution using simple matrix multiplication:</p>
<div id="1f129b74" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> convolution_with_im2col(im2col_matrix, kernel, out_shape):</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Perform convolution using im2col matrix multiplication."""</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Flatten kernel</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    kernel_flat <span class="op">=</span> kernel.flatten()</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Im2col matrix shape: </span><span class="sc">{</span>im2col_matrix<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Kernel flat shape: </span><span class="sc">{</span>kernel_flat<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Matrix multiplication: each row of im2col with kernel</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    output_flat <span class="op">=</span> im2col_matrix <span class="op">@</span> kernel_flat</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reshape to output dimensions</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> output_flat.reshape(out_shape)</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Output flat shape: </span><span class="sc">{</span>output_flat<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Final output shape: </span><span class="sc">{</span>output<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> output</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Perform convolution using im2col</span></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>out_shape <span class="op">=</span> reference_output.shape</span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>im2col_output <span class="op">=</span> convolution_with_im2col(im2col_numpy, kernel, out_shape)</span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a>print_matrix(im2col_output, <span class="st">"Convolution via Im2col"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Im2col matrix shape: (16, 9)
Kernel flat shape: (9,)
Output flat shape: (16,)
Final output shape: (4, 4)

Convolution via Im2col:
 26  32  38  44
 62  68  74  80
 98 104 110 116
134 140 146 152</code></pre>
</div>
</div>
<section id="final-verification-all-methods-equivalent" class="level3">
<h3 class="anchored" data-anchor-id="final-verification-all-methods-equivalent">Final Verification: All Methods Equivalent</h3>
<div id="a013e327" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Verify that all methods produce the same result</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>difference <span class="op">=</span> np.linalg.norm(reference_output <span class="op">-</span> im2col_output)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"L2 norm difference (naive vs im2col): </span><span class="sc">{</span>difference<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> difference <span class="op">&lt;</span> <span class="fl">1e-10</span>:</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"✅ SUCCESS: Im2col convolution matches naive reference!"</span>)</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"❌ ERROR: Im2col convolution differs from reference"</span>)</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Max difference: </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">max</span>(np.<span class="bu">abs</span>(reference_output <span class="op">-</span> im2col_output))<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>L2 norm difference (naive vs im2col): 0.0
✅ SUCCESS: Im2col convolution matches naive reference!</code></pre>
</div>
</div>
</section>
</section>
<section id="multi-channel-convolution" class="level2">
<h2 class="anchored" data-anchor-id="multi-channel-convolution">7. Multi-Channel Convolution</h2>
<p>Real-world deep learning scenarios involve multiple input and output channels. Let’s extend our approach:</p>
<div id="ff9b9917" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> multi_channel_convolution():</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Demonstrate multi-channel convolution."""</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create multi-channel input: 6x6x2 (2 input channels)</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    np.random.seed(<span class="dv">123</span>)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    input_tensor <span class="op">=</span> np.random.randint(<span class="dv">0</span>, <span class="dv">5</span>, (<span class="dv">6</span>, <span class="dv">6</span>, <span class="dv">2</span>))</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create multi-channel filters: 3x3x2x3 (2 input, 3 output channels)</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    filters <span class="op">=</span> np.random.randint(<span class="op">-</span><span class="dv">1</span>, <span class="dv">2</span>, (<span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">3</span>))</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>    H, W, C_in <span class="op">=</span> input_tensor.shape</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>    K, K, C_in_filter, C_out <span class="op">=</span> filters.shape</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>    out_h, out_w <span class="op">=</span> H <span class="op">-</span> K <span class="op">+</span> <span class="dv">1</span>, W <span class="op">-</span> K <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Input shape: </span><span class="sc">{</span>input_tensor<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Filters shape: </span><span class="sc">{</span>filters<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Output shape: (</span><span class="sc">{</span>out_h<span class="sc">}</span><span class="ss">, </span><span class="sc">{</span>out_w<span class="sc">}</span><span class="ss">, </span><span class="sc">{</span>C_out<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reference convolution with nested loops</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>    reference_output <span class="op">=</span> np.zeros((out_h, out_w, C_out))</span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(out_h):</span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(out_w):</span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> c_out <span class="kw">in</span> <span class="bu">range</span>(C_out):</span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a>                window <span class="op">=</span> input_tensor[i:i<span class="op">+</span>K, j:j<span class="op">+</span>K, :]  <span class="co"># [K, K, C_in]</span></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a>                reference_output[i, j, c_out] <span class="op">=</span> np.<span class="bu">sum</span>(window <span class="op">*</span> filters[:, :, :, c_out])</span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Im2col approach using direct as_strided (like the figure shows)</span></span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract all channels at once using as_strided</span></span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> numpy.lib.stride_tricks <span class="im">import</span> as_strided</span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create 5D windows [out_h, out_w, K, K, C_in] directly</span></span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a>    windows_5d <span class="op">=</span> as_strided(</span>
<span id="cb28-32"><a href="#cb28-32" aria-hidden="true" tabindex="-1"></a>        input_tensor,</span>
<span id="cb28-33"><a href="#cb28-33" aria-hidden="true" tabindex="-1"></a>        shape<span class="op">=</span>(out_h, out_w, K, K, C_in),</span>
<span id="cb28-34"><a href="#cb28-34" aria-hidden="true" tabindex="-1"></a>        strides<span class="op">=</span>(input_tensor.strides[<span class="dv">0</span>], input_tensor.strides[<span class="dv">1</span>], </span>
<span id="cb28-35"><a href="#cb28-35" aria-hidden="true" tabindex="-1"></a>                input_tensor.strides[<span class="dv">0</span>], input_tensor.strides[<span class="dv">1</span>], input_tensor.strides[<span class="dv">2</span>])</span>
<span id="cb28-36"><a href="#cb28-36" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb28-37"><a href="#cb28-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-38"><a href="#cb28-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert to im2col format: [num_windows, patch_size]</span></span>
<span id="cb28-39"><a href="#cb28-39" aria-hidden="true" tabindex="-1"></a>    num_windows <span class="op">=</span> out_h <span class="op">*</span> out_w</span>
<span id="cb28-40"><a href="#cb28-40" aria-hidden="true" tabindex="-1"></a>    patch_size <span class="op">=</span> K <span class="op">*</span> K <span class="op">*</span> C_in</span>
<span id="cb28-41"><a href="#cb28-41" aria-hidden="true" tabindex="-1"></a>    im2col_matrix <span class="op">=</span> windows_5d.reshape(num_windows, patch_size)</span>
<span id="cb28-42"><a href="#cb28-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-43"><a href="#cb28-43" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reshape filters and apply</span></span>
<span id="cb28-44"><a href="#cb28-44" aria-hidden="true" tabindex="-1"></a>    filters_reshaped <span class="op">=</span> filters.reshape(patch_size, C_out)</span>
<span id="cb28-45"><a href="#cb28-45" aria-hidden="true" tabindex="-1"></a>    im2col_output_flat <span class="op">=</span> im2col_matrix <span class="op">@</span> filters_reshaped</span>
<span id="cb28-46"><a href="#cb28-46" aria-hidden="true" tabindex="-1"></a>    im2col_output <span class="op">=</span> im2col_output_flat.reshape(out_h, out_w, C_out)</span>
<span id="cb28-47"><a href="#cb28-47" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-48"><a href="#cb28-48" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Im2col matrix shape: </span><span class="sc">{</span>im2col_matrix<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb28-49"><a href="#cb28-49" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Reshaped filters shape: </span><span class="sc">{</span>filters_reshaped<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb28-50"><a href="#cb28-50" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-51"><a href="#cb28-51" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compare results</span></span>
<span id="cb28-52"><a href="#cb28-52" aria-hidden="true" tabindex="-1"></a>    difference <span class="op">=</span> np.linalg.norm(reference_output <span class="op">-</span> im2col_output)</span>
<span id="cb28-53"><a href="#cb28-53" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">L2 norm difference (reference vs im2col): </span><span class="sc">{</span>difference<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb28-54"><a href="#cb28-54" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-55"><a href="#cb28-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> difference <span class="op">&lt;</span> <span class="fl">1e-10</span>:</span>
<span id="cb28-56"><a href="#cb28-56" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"✅ SUCCESS: Multi-channel im2col matches reference!"</span>)</span>
<span id="cb28-57"><a href="#cb28-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb28-58"><a href="#cb28-58" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"❌ ERROR: Multi-channel results differ"</span>)</span>
<span id="cb28-59"><a href="#cb28-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-60"><a href="#cb28-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> reference_output, im2col_output</span>
<span id="cb28-61"><a href="#cb28-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-62"><a href="#cb28-62" aria-hidden="true" tabindex="-1"></a><span class="co"># Run multi-channel demonstration</span></span>
<span id="cb28-63"><a href="#cb28-63" aria-hidden="true" tabindex="-1"></a>multi_channel_convolution()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Input shape: (6, 6, 2)
Filters shape: (3, 3, 2, 3)
Output shape: (4, 4, 3)

Im2col matrix shape: (16, 18)
Reshaped filters shape: (18, 3)

L2 norm difference (reference vs im2col): 0.0
✅ SUCCESS: Multi-channel im2col matches reference!</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="15">
<pre><code>(array([[[  8.,   8.,  -9.],
         [  7.,  14., -20.],
         [ -1.,   6., -13.],
         [  0.,   5., -13.]],
 
        [[  4.,  22., -11.],
         [  8.,   4., -10.],
         [ 11.,   2., -14.],
         [ 21.,  12., -16.]],
 
        [[  6.,   5., -12.],
         [ 14.,  13., -11.],
         [  4.,  19., -16.],
         [ 10.,   9., -14.]],
 
        [[ 21.,   5., -15.],
         [  8.,  10., -14.],
         [ 10.,   8., -11.],
         [  6.,  12., -16.]]]),
 array([[[  8,   8,  -9],
         [  7,  14, -20],
         [ -1,   6, -13],
         [  0,   5, -13]],
 
        [[  4,  22, -11],
         [  8,   4, -10],
         [ 11,   2, -14],
         [ 21,  12, -16]],
 
        [[  6,   5, -12],
         [ 14,  13, -11],
         [  4,  19, -16],
         [ 10,   9, -14]],
 
        [[ 21,   5, -15],
         [  8,  10, -14],
         [ 10,   8, -11],
         [  6,  12, -16]]]))</code></pre>
</div>
</div>
<p>For multi-channel convolution:</p>
<ul>
<li><strong>Input</strong>: <code>[H, W, C_in]</code></li>
<li><strong>Filters</strong>: <code>[K, K, C_in, C_out]</code></li>
<li><strong>Im2col matrix</strong>: <code>[num_windows, K×K×C_in]</code></li>
<li><strong>Reshaped filters</strong>: <code>[K×K×C_in, C_out]</code></li>
<li><strong>Output</strong>: <code>[out_h, out_w, C_out]</code></li>
</ul>
<p>The same im2col principle applies, but now each window includes all input channels, and we can compute all output channels simultaneously.</p>
</section>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">Summary</h2>
<p>We’ve demonstrated the complete evolution from naive convolution to optimized tensor descriptor-based implementation:</p>
<ol type="1">
<li><strong>Naive approach</strong>: Direct mathematical implementation with nested loops</li>
<li><strong>Window extraction</strong>: Using <code>as_strided</code> to create efficient memory views</li>
<li><strong>Tensor descriptors</strong>: Achieving the same with structured transformations</li>
<li><strong>Im2col transformation</strong>: Converting convolution to matrix multiplication</li>
<li><strong>Multi-channel extension</strong>: Scaling to realistic deep learning scenarios</li>
</ol>
<section id="key-insights" class="level3">
<h3 class="anchored" data-anchor-id="key-insights">Key Insights</h3>
<ul>
<li><strong>Memory efficiency</strong>: Tensor descriptors avoid data duplication by creating views</li>
<li><strong>Parallelization</strong>: Im2col enables massive parallelization through matrix multiplication</li>
<li><strong>Generalization</strong>: The tensor descriptor <strong>approach</strong> extends naturally to complex memory patterns</li>
<li><strong>GPU acceleration</strong>: These transformations form the foundation for efficient GPU kernels</li>
</ul>
<p>The tensor descriptor system provides a unified framework for describing these transformations, making it possible to generate efficient code for various hardware architectures automatically. It is also important to note that the tensor descriptor machinary is implmented in compile time C++ code, therefore very efficient. This python implementation is just a simulator to demonstrate the concept.</p>
</section>
<section id="performance-characteristics" class="level3">
<h3 class="anchored" data-anchor-id="performance-characteristics">Performance Characteristics</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Method</th>
<th>Memory Usage</th>
<th>Parallelization</th>
<th>GPU Suitability</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Naive loops</td>
<td>Low</td>
<td>Poor</td>
<td>Poor</td>
</tr>
<tr class="even">
<td>As_strided</td>
<td>Medium</td>
<td>Good</td>
<td>Limited</td>
</tr>
<tr class="odd">
<td>Tensor descriptors</td>
<td>Medium</td>
<td>Excellent</td>
<td>Excellent</td>
</tr>
<tr class="even">
<td>Im2col</td>
<td>High</td>
<td>Excellent</td>
<td>Excellent</td>
</tr>
</tbody>
</table>
<p>Tensor descriptors strike the optimal balance: they provide the parallelization benefits of im2col while maintaining the memory efficiency of strided operations, making them ideal for high-performance GPU implementations.</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>