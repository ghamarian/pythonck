---
title: "Sweep Tile - Elegant Iteration"
format: 
  live-html:
    mermaid:
      theme: default
---

## Overview

Sweep operations are the elegant way to iterate over distributed data. They complete the tile distribution workflow by providing clean, efficient iteration patterns that automatically handle all the complex indexing details.


```{pyodide}
#| echo: false
#| output: false
#| autorun: true

# Auto-install pythonck package
import micropip
await micropip.install("https://raw.githubusercontent.com/ghamarian/pythonck/master/documentation/pythonck-0.1.0-py3-none-any.whl")
```

## Basic Sweep Mechanism

```{=html}
<div class="mermaid">
flowchart LR
    subgraph "X-Tile (Reused)"
        XT["X data loaded once<br/>Stays in registers"]
    end
    
    subgraph "Y-Sweep"
        Y1["Y position 0"]
        Y2["Y position 1"]
        Y3["Y position 2"]
        YN["Y position N"]
    end
    
    subgraph "Computation"
        C["Process(X, Y)"]
    end
    
    XT --> C
    Y1 --> C
    Y2 --> C
    Y3 --> C
    YN --> C
    
    style XT fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
    style C fill:#e0e7ff,stroke:#4338ca,stroke-width:2px
</div>
```

The key insight: Load X data once, then sweep through Y positions while keeping X in fast memory.

```{pyodide}
#| echo: true
#| output: true

import numpy as np

# Simulate a simple 2D sweep operation
def simulate_sweep(matrix_shape, tile_shape):
    """Demonstrate sweep concept with a simple matrix"""
    M, N = matrix_shape
    tile_m, tile_n = tile_shape
    
    print(f"Matrix: {M}x{N}, Tile: {tile_m}x{tile_n}")
    print(f"Number of tiles: ({M//tile_m}, {N//tile_n})")
    print()
    
    # For each tile position
    for tile_i in range(0, M, tile_m):
        for tile_j in range(0, N, tile_n):
            print(f"Processing tile at ({tile_i}, {tile_j}):")
            
            # Load X-tile (column data) - happens once
            print(f"  Load X-tile: columns {tile_j} to {tile_j+tile_n-1}")
            
            # Sweep through Y positions in this tile
            for y in range(tile_i, min(tile_i + tile_m, M)):
                print(f"    Sweep Y={y}: process row {y} with loaded columns")
            print()

# Example: 6x8 matrix with 2x4 tiles
simulate_sweep((6, 8), (2, 4))
```

## The Power of SweepTile

### 1. Memory Efficiency

```{=html}
<div class="mermaid">
graph TB
    subgraph "Traditional Approach"
        T1["Load X[0]"] --> P1["Process"]
        T2["Load Y[0]"] --> P1
        T3["Load X[0]"] --> P2["Process"]
        T4["Load Y[1]"] --> P2
        T5["Load X[0]"] --> P3["Process"]
        T6["Load Y[2]"] --> P3
        Note1["X loaded 3 times!"]
    end
    
    subgraph "Sweep Approach"
        S1["Load X[0]"] --> SP["Process with<br/>Y[0], Y[1], Y[2]"]
        S2["Load Y[0,1,2]"] --> SP
        Note2["X loaded once!"]
    end
    
    style Note1 fill:#fee2e2,stroke:#ef4444,stroke-width:2px
    style Note2 fill:#d1fae5,stroke:#10b981,stroke-width:2px
</div>
```

### 2. Code Example

```{pyodide}
#| echo: true
#| output: true

# Conceptual sweep implementation
class SweepTileSimulation:
    def __init__(self, data, tile_shape):
        self.data = data
        self.tile_shape = tile_shape
        
    def sweep_gemm_tile(self, tile_row, tile_col):
        """Simulate GEMM sweep for one tile"""
        tile_m, tile_n = self.tile_shape
        
        # Phase 1: Load X tile (A matrix columns)
        print(f"Loading A tile columns {tile_col} to {tile_col + tile_n - 1}")
        a_tile = self.data[tile_row:tile_row+tile_m, tile_col:tile_col+tile_n]
        
        # Phase 2: Sweep through B rows
        results = []
        for b_row in range(self.data.shape[0]):
            # In real GPU: B row data streams through
            b_data = self.data[b_row, tile_col:tile_col+tile_n]
            
            # Compute dot products
            for a_row in range(a_tile.shape[0]):
                result = np.dot(a_tile[a_row], b_data)
                results.append((tile_row + a_row, b_row, result))
                
        return results

# Example usage
data = np.arange(16).reshape(4, 4)
sweep = SweepTileSimulation(data, (2, 2))

print("Data matrix:")
print(data)
print("\nSweeping tile at (0, 0):")
results = sweep.sweep_gemm_tile(0, 0)
for r in results[:4]:  # Show first few results
    print(f"  Result[{r[0]},{r[1]}] = {r[2]}")
```

## C++ Implementation Pattern

```cpp
// Sweep pattern for matrix multiplication
template<typename ADataType, typename BDataType, typename CDataType>
__device__ void gemm_sweep_tile(
    const TileDistribution& dist_a,
    const TileDistribution& dist_b,
    TileDistribution& dist_c)
{
    // Phase 1: Load A tile into registers (X dimension)
    auto a_tile = make_distributed_tensor(dist_a);
    a_tile.load();  // Load once, reuse many times
    
    // Phase 2: Create sweep for B (Y dimension)
    auto b_sweep = make_sweep_tile(dist_b);
    
    // Phase 3: Sweep through B positions
    sweep_tile(b_sweep, [&](auto b_slice) {
        // b_slice is current Y position data
        
        // Compute C = A * B for this Y position
        auto c_slice = make_distributed_tensor(dist_c);
        
        // Actual computation
        gemm(a_tile, b_slice, c_slice);
        
        // Store result
        c_slice.store();
    });
}
```

## Sweep Patterns

### Pattern 1: Simple Linear Sweep

```{=html}
<div class="mermaid">
graph LR
    subgraph "Linear Sweep"
        S0["Start"] --> P0["Y[0]"]
        P0 --> P1["Y[1]"]
        P1 --> P2["Y[2]"]
        P2 --> P3["Y[3]"]
        P3 --> E["End"]
    end
    
    style S0 fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
    style E fill:#ffebee,stroke:#d32f2f,stroke-width:2px
</div>
```

```{pyodide}
#| echo: true
#| output: true

def linear_sweep(data, x_indices, y_range):
    """Simple linear sweep pattern"""
    # Load X data once
    x_data = data[:, x_indices]
    print(f"Loaded X data (shape {x_data.shape}):")
    print(x_data)
    
    # Sweep through Y
    print("\nSweeping Y positions:")
    for y in y_range:
        y_data = data[y, :]
        result = np.dot(x_data.T, y_data)
        print(f"  Y[{y}]: {y_data} â†’ result: {result}")

# Example
data = np.arange(20).reshape(4, 5)
print("Original data:")
print(data)
print()

linear_sweep(data, [0, 2], range(4))
```

### Pattern 2: Strided Sweep

```{pyodide}
#| echo: true
#| output: true

def strided_sweep(data, x_tile, y_start, y_stride, y_count):
    """Sweep with stride - useful for interleaved data"""
    # Load X tile
    x_data = data[:, x_tile[0]:x_tile[1]]
    print(f"X tile: columns {x_tile[0]} to {x_tile[1]-1}")
    
    # Strided sweep through Y
    print(f"Strided sweep: start={y_start}, stride={y_stride}, count={y_count}")
    for i in range(y_count):
        y_pos = y_start + i * y_stride
        if y_pos < data.shape[0]:
            print(f"  Process Y[{y_pos}]")

# Example: Process every other row
data = np.arange(24).reshape(6, 4)
strided_sweep(data, (0, 2), y_start=0, y_stride=2, y_count=3)
```

### Pattern 3: Block Sweep

```{pyodide}
#| echo: true
#| output: true

def block_sweep(data, x_tile, y_blocks):
    """Sweep through blocks of Y - useful for cache optimization"""
    print(f"X tile loaded: columns {x_tile}")
    
    for block_id, y_block in enumerate(y_blocks):
        print(f"\nBlock {block_id}: Y[{y_block[0]}:{y_block[1]}]")
        block_data = data[y_block[0]:y_block[1], :]
        print(f"  Processing {block_data.shape[0]} rows together")
        # In GPU: This block fits in shared memory

# Example: Process Y in blocks of 2
data = np.arange(32).reshape(8, 4)
block_sweep(data, [0, 2], [(0, 2), (2, 4), (4, 6), (6, 8)])
```

## Performance Characteristics

```{=html}
<div class="mermaid">
graph TB
    subgraph "Sweep Performance Benefits"
        B1["Zero runtime overhead<br/>Compile-time unrolling"]
        B2["Perfect memory coalescing<br/>Sequential access patterns"]
        B3["Automatic vectorization<br/>Compiler optimizations"]
        B4["Register reuse<br/>X data stays in VGPR"]
    end
    
    subgraph "Use Cases"
        U1["Matrix Multiplication<br/>Reuse A columns"]
        U2["Convolution<br/>Reuse filter weights"]
        U3["Reduction<br/>Accumulate over Y"]
        U4["Broadcast<br/>Apply X to all Y"]
    end
    
    B1 --> Performance["High Performance"]
    B2 --> Performance
    B3 --> Performance
    B4 --> Performance
    
    Performance --> U1
    Performance --> U2
    Performance --> U3
    Performance --> U4
    
    style Performance fill:#d1fae5,stroke:#10b981,stroke-width:3px
</div>
```

## Advanced Sweep Features

### 1. Conditional Sweep

```{pyodide}
#| echo: true
#| output: true

def conditional_sweep(data, x_tile, condition_fn):
    """Sweep only positions that meet condition"""
    x_data = data[:, x_tile[0]:x_tile[1]]
    
    swept_positions = []
    for y in range(data.shape[0]):
        if condition_fn(y):
            swept_positions.append(y)
            # Process this Y position
            
    print(f"Swept {len(swept_positions)} of {data.shape[0]} positions")
    print(f"Positions: {swept_positions}")

# Example: Only process even rows
data = np.arange(20).reshape(5, 4)
conditional_sweep(data, (0, 2), lambda y: y % 2 == 0)
```

### 2. Multi-Dimensional Sweep

```cpp
// C++ example: 3D sweep for tensor operations
template<typename XTensor, typename YTensor>
__device__ void tensor_3d_sweep(
    const XTensor& x_tensor,    // 2D slice loaded
    const YTensor& y_tensor)    // 3D tensor to sweep
{
    // Sweep through depth dimension
    constexpr auto depth = y_tensor.get_shape()[2];
    
    static_for<0, depth, 1>{}([&](auto z) {
        // Get 2D slice at depth z
        auto y_slice = y_tensor.get_slice(make_tuple(_, _, z));
        
        // Process x_tensor with y_slice
        auto result = tensor_op(x_tensor, y_slice);
        
        // Store or accumulate result
        store_result(result, z);
    });
}
```

### 3. Sweep with Accumulation

```{pyodide}
#| echo: true
#| output: true

def accumulation_sweep(data, x_tile):
    """Sweep with running accumulation"""
    x_data = data[:, x_tile[0]:x_tile[1]]
    
    accumulator = np.zeros(x_data.shape[1])
    print(f"Initial accumulator: {accumulator}")
    
    for y in range(data.shape[0]):
        y_data = data[y, x_tile[0]:x_tile[1]]
        accumulator += y_data
        print(f"  After Y[{y}]: {accumulator}")
    
    print(f"Final result: {accumulator}")

# Example
data = np.arange(12).reshape(3, 4)
print("Data:")
print(data)
print("\nAccumulating columns 1 and 2:")
accumulation_sweep(data, (1, 3))
```

## Integration with Tile Distribution

```{=html}
<div class="mermaid">
flowchart TB
    subgraph "Complete Workflow"
        TD["TileDistribution<br/>Define data layout"]
        TW["TileWindow<br/>Create view"]
        DT["DistributedTensor<br/>Load X data"]
        ST["SweepTile<br/>Iterate Y positions"]
        R["Results<br/>Store outputs"]
    end
    
    TD --> TW
    TW --> DT
    DT --> ST
    ST --> R
    
    style TD fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    style ST fill:#fff3e0,stroke:#f57c00,stroke-width:3px
    style R fill:#e8f5e9,stroke:#388e3c,stroke-width:2px
</div>
```

## Summary

SweepTile provides:
- **Efficiency**: Load once, use many times
- **Simplicity**: Clean iteration abstraction
- **Performance**: Zero overhead, perfect patterns
- **Flexibility**: Various sweep patterns for different algorithms

Key benefits:
1. **Memory bandwidth**: Optimal reuse of loaded data
2. **Register pressure**: Keep hot data in fastest memory
3. **Code clarity**: Express algorithms naturally
4. **Compiler optimization**: Enable aggressive optimizations

The sweep pattern is fundamental to high-performance GPU kernels, turning complex iteration patterns into simple, efficient operations.